{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n  return new Promise((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n    const request = indexedDB.open(dbName, version);\n    let db;\n    request.onsuccess = event => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = event => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = event => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n  if (!indexedDB) {\n    return;\n  }\n  const request = indexedDB.open(dbName, version);\n  request.onupgradeneeded = event => {\n    const database = event.target.result;\n    storeSchemas.forEach(storeSchema => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n        storeSchema.storeSchema.forEach(schema => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n    const storeMigrations = migrationFactory && migrationFactory();\n    if (storeMigrations) {\n      Object.keys(storeMigrations).map(k => parseInt(k, 10)).filter(v => v > event.oldVersion).sort((a, b) => a - b).forEach(v => {\n        storeMigrations[v](database, request.transaction);\n      });\n    }\n    database.close();\n  };\n  request.onsuccess = e => {\n    e.target.result.close();\n  };\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n  return new Observable(obs => {\n    try {\n      const newVersion = version + 1;\n      const request = indexedDB.open(dbName, newVersion);\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n      request.onerror = e => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n}\nfunction validateStoreName(db, storeName) {\n  return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\nfunction createTransaction(db, options) {\n  const trans = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n  return {\n    storeName,\n    dbMode: type,\n    error: e => {\n      reject(e);\n    },\n    abort: e => {\n      reject(e);\n    }\n  };\n}\nvar DBMode;\n(function (DBMode) {\n  DBMode[\"readonly\"] = \"readonly\";\n  DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\nclass NgxIndexedDBService {\n  constructor(dbConfig, platformId) {\n    this.dbConfig = dbConfig;\n    this.platformId = platformId;\n    if (!dbConfig.name) {\n      throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n    }\n    if (!dbConfig.version) {\n      throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n    }\n    this.isBrowser = isPlatformBrowser(this.platformId);\n    if (this.isBrowser) {\n      this.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n      openDatabase(this.indexedDB, dbConfig.name).then(db => {\n        if (db.version !== dbConfig.version) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n            console.warn(`Using latest version ${db.version}`);\n          }\n          this.dbConfig.version = db.version;\n        }\n      });\n    }\n  }\n  /**\n   * Allows to crate a new object store ad-hoc\n   * @param storeName The name of the store to be created\n   * @param migrationFactory The migration factory if exists\n   */\n  createObjectStore(storeSchema, migrationFactory) {\n    const storeSchemas = [storeSchema];\n    CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n  }\n  /**\n   * Adds new entry in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param value The entry to be added\n   * @param key The optional key for the entry\n   */\n  add(storeName, value, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n        request.onsuccess = evt => __awaiter(this, void 0, void 0, function* () {\n          const result = evt.target.result;\n          const getRequest = objectStore.get(result);\n          getRequest.onsuccess = event => {\n            obs.next(event.target.result);\n            obs.complete();\n          };\n        });\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Adds new entries in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param values The entries to be added containing optional key attribute\n   */\n  bulkAdd(storeName, values) {\n    const promises = new Promise((resolve, reject) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n        const objectStore = transaction.objectStore(storeName);\n        const results = values.map(value => {\n          return new Promise((resolve1, reject1) => {\n            const key = value.key;\n            delete value.key;\n            const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n            request.onsuccess = evt => {\n              const result = evt.target.result;\n              resolve1(result);\n            };\n          });\n        });\n        resolve(Promise.all(results));\n      }).catch(reason => reject(reason));\n    });\n    return from(promises);\n  }\n  /**\n   * Delete entries in the store and returns current entries in the store\n   * @param storeName The name of the store to add the item\n   * @param keys The keys to be deleted\n   */\n  bulkDelete(storeName, keys) {\n    const promises = keys.map(key => {\n      return new Promise((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n          transaction.oncomplete = () => {\n            this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n              resolve(newValues);\n            });\n          };\n        }).catch(reason => reject(reason));\n      });\n    });\n    return from(Promise.all(promises));\n  }\n  /**\n   * Returns entry by key.\n   * @param storeName The name of the store to query\n   * @param key The entry key\n   */\n  getByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(key);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n        request.onerror = event => {\n          obs.error(event);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Retrieve multiple entries in the store\n   * @param storeName The name of the store to retrieve the items\n   * @param keys The ids entries to be retrieve\n   */\n  bulkGet(storeName, keys) {\n    const observables = keys.map(key => this.getByKey(storeName, key));\n    return new Observable(obs => {\n      combineLatest(observables).subscribe(values => {\n        obs.next(values);\n        obs.complete();\n      });\n    });\n  }\n  /**\n   * Returns entry by id.\n   * @param storeName The name of the store to query\n   * @param id The entry id\n   */\n  getByID(storeName, id) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(id);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns entry by index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param key The entry key.\n   */\n  getByIndex(storeName, indexName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.get(key);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Return all elements from one store\n   * @param storeName The name of the store to select the items\n   */\n  getAll(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.getAll();\n        request.onerror = evt => {\n          obs.error(evt);\n        };\n        request.onsuccess = ({\n          target: {\n            result: ResultAll\n          }\n        }) => {\n          obs.next(ResultAll);\n          obs.complete();\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Adds or updates a record in store with the given value and key. Return all items present in the store\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   */\n  update(storeName, value) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.put(value);\n        request.onsuccess = evt => __awaiter(this, void 0, void 0, function* () {\n          const result = evt.target.result;\n          const getRequest = objectStore.get(result);\n          getRequest.onsuccess = event => {\n            obs.next(event.target.result);\n            obs.complete();\n          };\n        });\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns all items from the store after delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  delete(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.delete(key);\n        transaction.oncomplete = () => {\n          this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n            obs.next(newValues);\n            obs.complete();\n          });\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true from the store after a successful delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  deleteByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n        objectStore.delete(key);\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete all entries from the store.\n   * @param storeName The name of the store to have the entries deleted\n   */\n  clear(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.clear();\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete the DB.\n   */\n  deleteDatabase() {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => __awaiter(this, void 0, void 0, function* () {\n        yield db.close();\n        const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n        deleteDBRequest.onsuccess = () => {\n          obs.next(true);\n          obs.complete();\n        };\n        deleteDBRequest.onerror = error => obs.error(error);\n        deleteDBRequest.onblocked = () => {\n          throw new Error(`Unable to delete database because it's blocked`);\n        };\n      })).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns the open cursor event\n   * @param storeName The name of the store to have the entries deleted\n   * @param keyRange The key range which the cursor should be open on\n   */\n  openCursor(storeName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n        request.onsuccess = event => {\n          obs.next(event);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Open a cursor by index filter.\n   * @param storeName The name of the store to query.\n   * @param indexName The index name to filter.\n   * @param keyRange The range value and criteria to apply on the index.\n   */\n  openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n    const obs = new Subject();\n    openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n      validateBeforeTransaction(db, storeName, reason => {\n        obs.error(reason);\n      });\n      const transaction = createTransaction(db, optionsGenerator(mode, storeName, reason => {\n        obs.error(reason);\n      }, () => {\n        obs.next();\n      }));\n      const objectStore = transaction.objectStore(storeName);\n      const index = objectStore.index(indexName);\n      const request = index.openCursor(keyRange);\n      request.onsuccess = event => {\n        obs.next(event);\n      };\n    }).catch(reason => obs.error(reason));\n    return obs;\n  }\n  /**\n   * Returns all items by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange);\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            data.push(cursor.value);\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns all primary keys by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllKeysByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openKeyCursor(keyRange);\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            data.push({\n              primaryKey: cursor.primaryKey,\n              key: cursor.key\n            });\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  count(storeName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.count(keyRange);\n        request.onerror = e => obs.error(e);\n        request.onsuccess = e => {\n          obs.next(e.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  countByIndex(storeName, indexName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.count(keyRange);\n        request.onerror = e => obs.error(e);\n        request.onsuccess = e => {\n          obs.next(e.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Delete the store by name.\n   * @param storeName The name of the store to query\n   */\n  deleteObjectStore(storeName) {\n    return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n  }\n}\nNgxIndexedDBService.ɵfac = function NgxIndexedDBService_Factory(t) {\n  return new (t || NgxIndexedDBService)(i0.ɵɵinject(CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID));\n};\nNgxIndexedDBService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxIndexedDBService,\n  factory: NgxIndexedDBService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [CONFIG_TOKEN]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nclass NgxIndexedDBModule {\n  static forRoot(dbConfig) {\n    return {\n      ngModule: NgxIndexedDBModule,\n      providers: [NgxIndexedDBService, {\n        provide: CONFIG_TOKEN,\n        useValue: dbConfig\n      }]\n    };\n  }\n}\nNgxIndexedDBModule.ɵfac = function NgxIndexedDBModule_Factory(t) {\n  return new (t || NgxIndexedDBModule)();\n};\nNgxIndexedDBModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxIndexedDBModule\n});\nNgxIndexedDBModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [],\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };","map":{"version":3,"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","NgModule","isPlatformBrowser","CommonModule","__awaiter","Observable","from","combineLatest","Subject","take","openDatabase","indexedDB","dbName","version","upgradeCallback","Promise","resolve","reject","request","open","db","onsuccess","event","result","onerror","error","onupgradeneeded","CreateObjectStore","storeSchemas","migrationFactory","database","target","forEach","storeSchema","objectStoreNames","contains","store","objectStore","createObjectStore","storeConfig","schema","createIndex","name","keypath","options","storeMigrations","Object","keys","map","k","parseInt","filter","v","oldVersion","sort","a","b","transaction","close","e","DeleteObjectStore","storeName","Error","obs","newVersion","deleteObjectStore","console","log","next","complete","validateStoreName","validateBeforeTransaction","createTransaction","trans","dbMode","onabort","abort","optionsGenerator","type","DBMode","CONFIG_TOKEN","NgxIndexedDBService","constructor","dbConfig","platformId","isBrowser","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","objectStoresMeta","then","process","env","NODE_ENV","warn","add","value","key","readwrite","Boolean","evt","getRequest","get","catch","bulkAdd","values","promises","results","resolve1","reject1","all","reason","bulkDelete","delete","oncomplete","getAll","pipe","subscribe","newValues","getByKey","readonly","bulkGet","observables","getByID","id","getByIndex","indexName","index","ResultAll","update","put","deleteByKey","clear","deleteDatabase","deleteDBRequest","onblocked","openCursor","keyRange","undefined","openCursorByIndex","mode","getAllByIndex","data","cursor","push","continue","getAllKeysByIndex","openKeyCursor","primaryKey","count","countByIndex","ɵfac","NgxIndexedDBService_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","decorators","args","NgxIndexedDBModule","forRoot","ngModule","providers","provide","useValue","NgxIndexedDBModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","declarations"],"sources":["C:/Users/guita/Documents/GitHub/MisTechosAsturias2/node_modules/ngx-indexed-db/fesm2015/ngx-indexed-db.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n    return new Promise((resolve, reject) => {\n        if (!indexedDB) {\n            reject('IndexedDB not available');\n        }\n        const request = indexedDB.open(dbName, version);\n        let db;\n        request.onsuccess = (event) => {\n            db = request.result;\n            resolve(db);\n        };\n        request.onerror = (event) => {\n            reject(`IndexedDB error: ${request.error}`);\n        };\n        if (typeof upgradeCallback === 'function') {\n            request.onupgradeneeded = (event) => {\n                upgradeCallback(event, db);\n            };\n        }\n    });\n}\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    if (!indexedDB) {\n        return;\n    }\n    const request = indexedDB.open(dbName, version);\n    request.onupgradeneeded = (event) => {\n        const database = event.target.result;\n        storeSchemas.forEach((storeSchema) => {\n            if (!database.objectStoreNames.contains(storeSchema.store)) {\n                const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                storeSchema.storeSchema.forEach((schema) => {\n                    objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                });\n            }\n        });\n        const storeMigrations = migrationFactory && migrationFactory();\n        if (storeMigrations) {\n            Object.keys(storeMigrations)\n                .map((k) => parseInt(k, 10))\n                .filter((v) => v > event.oldVersion)\n                .sort((a, b) => a - b)\n                .forEach((v) => {\n                storeMigrations[v](database, request.transaction);\n            });\n        }\n        database.close();\n    };\n    request.onsuccess = (e) => {\n        e.target.result.close();\n    };\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n    if (!dbName || !version || !storeName) {\n        throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n    }\n    return new Observable((obs) => {\n        try {\n            const newVersion = version + 1;\n            const request = indexedDB.open(dbName, newVersion);\n            request.onupgradeneeded = (event) => {\n                const database = event.target.result;\n                database.deleteObjectStore(storeName);\n                database.close();\n                console.log('onupgradeneeded');\n                obs.next(true);\n                obs.complete();\n            };\n            request.onerror = (e) => obs.error(e);\n        }\n        catch (error) {\n            obs.error(error);\n        }\n    });\n}\n\nfunction validateStoreName(db, storeName) {\n    return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n    if (!db) {\n        reject('You need to use the openDatabase function to create a database before you query it!');\n    }\n    if (!validateStoreName(db, storeName)) {\n        reject(`objectStore does not exists: ${storeName}`);\n    }\n}\nfunction createTransaction(db, options) {\n    const trans = db.transaction(options.storeName, options.dbMode);\n    trans.onerror = options.error;\n    trans.onabort = options.abort;\n    return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n    return {\n        storeName,\n        dbMode: type,\n        error: (e) => {\n            reject(e);\n        },\n        abort: (e) => {\n            reject(e);\n        },\n    };\n}\n\nvar DBMode;\n(function (DBMode) {\n    DBMode[\"readonly\"] = \"readonly\";\n    DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\n\nclass NgxIndexedDBService {\n    constructor(dbConfig, platformId) {\n        this.dbConfig = dbConfig;\n        this.platformId = platformId;\n        if (!dbConfig.name) {\n            throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n        }\n        if (!dbConfig.version) {\n            throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n        }\n        this.isBrowser = isPlatformBrowser(this.platformId);\n        if (this.isBrowser) {\n            this.indexedDB =\n                window.indexedDB ||\n                    window.mozIndexedDB ||\n                    window.webkitIndexedDB ||\n                    window.msIndexedDB;\n            CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n            openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n                if (db.version !== dbConfig.version) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n                        console.warn(`Using latest version ${db.version}`);\n                    }\n                    this.dbConfig.version = db.version;\n                }\n            });\n        }\n    }\n    /**\n     * Allows to crate a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n    createObjectStore(storeSchema, migrationFactory) {\n        const storeSchemas = [storeSchema];\n        CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n    add(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n                request.onsuccess = (evt) => __awaiter(this, void 0, void 0, function* () {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                });\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n    bulkAdd(storeName, values) {\n        const promises = new Promise((resolve, reject) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n                const objectStore = transaction.objectStore(storeName);\n                const results = values.map((value) => {\n                    return new Promise((resolve1, reject1) => {\n                        const key = value.key;\n                        delete value.key;\n                        const request = Boolean(key)\n                            ? objectStore.add(value, key)\n                            : objectStore.add(value);\n                        request.onsuccess = (evt) => {\n                            const result = evt.target.result;\n                            resolve1(result);\n                        };\n                    });\n                });\n                resolve(Promise.all(results));\n            }).catch((reason) => reject(reason));\n        });\n        return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n    bulkDelete(storeName, keys) {\n        const promises = keys.map((key) => {\n            return new Promise((resolve, reject) => {\n                openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                    .then((db) => {\n                    const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n                    const objectStore = transaction.objectStore(storeName);\n                    objectStore.delete(key);\n                    transaction.oncomplete = () => {\n                        this.getAll(storeName)\n                            .pipe(take(1))\n                            .subscribe((newValues) => {\n                            resolve(newValues);\n                        });\n                    };\n                })\n                    .catch((reason) => reject(reason));\n            });\n        });\n        return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n    getByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n    bulkGet(storeName, keys) {\n        const observables = keys.map((key) => this.getByKey(storeName, key));\n        return new Observable((obs) => {\n            combineLatest(observables).subscribe((values) => {\n                obs.next(values);\n                obs.complete();\n            });\n        });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n    getByID(storeName, id) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(id);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n    getByIndex(storeName, indexName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n    getAll(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.getAll();\n                request.onerror = (evt) => {\n                    obs.error(evt);\n                };\n                request.onsuccess = ({ target: { result: ResultAll } }) => {\n                    obs.next(ResultAll);\n                    obs.complete();\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     */\n    update(storeName, value) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.put(value);\n                request.onsuccess = (evt) => __awaiter(this, void 0, void 0, function* () {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                });\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    delete(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.delete(key);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    deleteByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                objectStore.delete(key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n    clear(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.clear();\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n    deleteDatabase() {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => __awaiter(this, void 0, void 0, function* () {\n                yield db.close();\n                const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n                deleteDBRequest.onsuccess = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                deleteDBRequest.onerror = (error) => obs.error(error);\n                deleteDBRequest.onblocked = () => {\n                    throw new Error(`Unable to delete database because it's blocked`);\n                };\n            }))\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n    openCursor(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    obs.next(event);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n    openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n        const obs = new Subject();\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n            .then((db) => {\n            validateBeforeTransaction(db, storeName, (reason) => {\n                obs.error(reason);\n            });\n            const transaction = createTransaction(db, optionsGenerator(mode, storeName, (reason) => {\n                obs.error(reason);\n            }, () => {\n                obs.next();\n            }));\n            const objectStore = transaction.objectStore(storeName);\n            const index = objectStore.index(indexName);\n            const request = index.openCursor(keyRange);\n            request.onsuccess = (event) => {\n                obs.next(event);\n            };\n        })\n            .catch((reason) => obs.error(reason));\n        return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push(cursor.value);\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openKeyCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    count(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    countByIndex(storeName, indexName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n    deleteObjectStore(storeName) {\n        return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n}\nNgxIndexedDBService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, deps: [{ token: CONFIG_TOKEN }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxIndexedDBService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [CONFIG_TOKEN]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [PLATFORM_ID]\n                    }] }];\n    } });\n\nclass NgxIndexedDBModule {\n    static forRoot(dbConfig) {\n        return {\n            ngModule: NgxIndexedDBModule,\n            providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n        };\n    }\n}\nNgxIndexedDBModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxIndexedDBModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] });\nNgxIndexedDBModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [[CommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [],\n                    imports: [CommonModule]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}