{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/reproj/common.js", "../../../../../../node_modules/ol/reproj/Triangulation.js", "../../../../../../node_modules/ol/source/common.js", "../../../../../../node_modules/ol/reproj.js", "../../../../../../node_modules/ol/reproj/Tile.js", "../../../../../../node_modules/ol/source/TileEventType.js", "../../../../../../node_modules/ol/tilegrid/TileGrid.js", "../../../../../../node_modules/ol/tilegrid.js", "../../../../../../node_modules/ol/source/Tile.js", "../../../../../../node_modules/ol/tileurlfunction.js", "../../../../../../node_modules/ol/source/UrlTile.js", "../../../../../../node_modules/ol/source/TileImage.js", "../../../../../../node_modules/ol/source/XYZ.js", "../../../../../../node_modules/ol/source/OSM.js"],
  "sourcesContent": ["/**\n * @module ol/reproj/common\n */\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport var ERROR_THRESHOLD = 0.5;\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\nexport var ENABLE_RASTER_REPROJECTION = true;\n", "/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { log2, modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target\n */\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /** @class */function () {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n   */\n  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    var transformInvCache = {};\n    var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      var key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    var destinationTopLeft = getTopLeft(targetExtent);\n    var destinationTopRight = getTopRight(targetExtent);\n    var destinationBottomRight = getBottomRight(targetExtent);\n    var destinationBottomLeft = getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n    if (this.wrapsXInSource_) {\n      var leftBound_1 = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(function (triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {\n          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      }.bind(this));\n    }\n    transformInvCache = {};\n  }\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  };\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    var needsSubdivision = false;\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        var targetQuadExtent = boundingExtent([a, b, c, d]);\n        var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n    var isNotFinite = 0;\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n            return;\n          }\n        }\n      }\n    }\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        var centerSrc = this.transformInv_(center);\n        var dx = void 0;\n        if (wrapsX) {\n          var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        var centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          var bcSrc = this.transformInv_(bc);\n          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          var daSrc = this.transformInv_(da);\n          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          var abSrc = this.transformInv_(ab);\n          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          var cdSrc = this.transformInv_(cd);\n          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n        return;\n      }\n    }\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  };\n  /**\n   * Calculates extent of the 'source' coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  Triangulation.prototype.calculateSourceExtent = function () {\n    var extent = createEmpty();\n    this.triangles_.forEach(function (triangle, i, arr) {\n      var src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n    return extent;\n  };\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  Triangulation.prototype.getTriangles = function () {\n    return this.triangles_;\n  };\n  return Triangulation;\n}();\nexport default Triangulation;\n", "/**\n * @module ol/source/common\n */\n/**\n * Default WMS version.\n * @type {string}\n */\nexport var DEFAULT_WMS_VERSION = '1.3.0';\n/**\n * Context options to disable image smoothing.\n * @type {Object}\n */\nexport var IMAGE_SMOOTHING_DISABLED = {\n  imageSmoothingEnabled: false,\n  msImageSmoothingEnabled: false\n};\n", "/**\n * @module ol/reproj\n */\nimport { IMAGE_SMOOTHING_DISABLED } from './source/common.js';\nimport { assign } from './obj.js';\nimport { containsCoordinate, createEmpty, extend, forEachCorner, getCenter, getHeight, getTopLeft, getWidth } from './extent.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { getPointResolution, transform } from './proj.js';\nimport { solveLinearSystem } from './math.js';\nvar brokenDiagonalRendering_;\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;\n}\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    var ctx = document.createElement('canvas').getContext('2d');\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    var data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);\n  }\n  return brokenDiagonalRendering_;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n  var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n  // calculate the ideal resolution of the source data\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n  var sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n  return sourceResolution;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {\n  var targetCenter = getCenter(targetExtent);\n  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n  return sourceResolution;\n}\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @param {object=} opt_contextOptions Properties to set on the canvas context.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {\n  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n  assign(context, opt_contextOptions);\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n  context.scale(pixelRatio, pixelRatio);\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n  context.globalCompositeOperation = 'lighter';\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n  assign(stitchContext, opt_contextOptions);\n  var stitchScale = pixelRatio / sourceResolution;\n  sources.forEach(function (src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n    }\n  });\n  var targetTopLeft = getTopLeft(targetExtent);\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0],\n      y0 = source[0][1];\n    var x1 = source[1][0],\n      y1 = source[1][1];\n    var x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);\n    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);\n    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n    context.save();\n    context.beginPath();\n    if (isBrokenDiagonalRendering() || opt_contextOptions === IMAGE_SMOOTHING_DISABLED) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      var steps = 4;\n      var ud = u0 - u1;\n      var vd = v0 - v1;\n      for (var step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n  if (opt_renderEdges) {\n    context.save();\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n  return context.canvas;\n}\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */function (_super) {\n  __extends(ReprojTile, _super);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   * @param {object=} opt_contextOptions Properties to set on the canvas context.\n   */\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {\n    var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {object}\n     */\n    _this.contextOptions_ = opt_contextOptions;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    _this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n    return _this;\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function () {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n  ReprojTile.prototype.load = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey_1);\n              leftToLoad_1--;\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  return ReprojTile;\n}(Tile);\nexport default ReprojTile;\n", "/**\n * @module ol/source/TileEventType\n */\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n  /**\n   * Triggered if tile loading results in an error.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror'\n};\n", "/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { clamp } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = /** @class */function () {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  function TileGrid(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(isSorted(this.resolutions_, function (a, b) {\n      return b - a;\n    }, true), 17); // `resolutions` must be sorted in descending order\n    // check if we've got a consistent zoom factor and origin\n    var zoomFactor;\n    if (!options.origins) {\n      for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n    }\n    var extent = options.extent;\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n    assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\n    assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\n        var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n        if (extent) {\n          var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {\n    var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  };\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {\n    var tileRange, x, y;\n    var tileCoordExtent = null;\n    var z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    }\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  };\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  TileGrid.prototype.getExtent = function () {\n    return this.extent_;\n  };\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  TileGrid.prototype.getMaxZoom = function () {\n    return this.maxZoom;\n  };\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  TileGrid.prototype.getMinZoom = function () {\n    return this.minZoom;\n  };\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  TileGrid.prototype.getOrigin = function (z) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z];\n    }\n  };\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  TileGrid.prototype.getResolution = function (z) {\n    return this.resolutions_[z];\n  };\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  TileGrid.prototype.getResolutions = function () {\n    return this.resolutions_;\n  };\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        var minX = tileCoord[1] * 2;\n        var minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n      }\n      var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n    }\n    return null;\n  };\n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n    var origin = this.getOrigin(z);\n    var resolution = this.getResolution(z);\n    var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  };\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n    var tileCoord = tmpTileCoord;\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n    var minX = tileCoord[1];\n    var minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n    return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n  };\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  TileGrid.prototype.getTileCoordCenter = function (tileCoord) {\n    var origin = this.getOrigin(tileCoord[0]);\n    var resolution = this.getResolution(tileCoord[0]);\n    var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];\n  };\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n    var origin = this.getOrigin(tileCoord[0]);\n    var resolution = this.getResolution(tileCoord[0]);\n    var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    var maxX = minX + tileSize[0] * resolution;\n    var maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  };\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n  };\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n    var z = this.getZForResolution(resolution);\n    var scale = resolution / this.getResolution(z);\n    var origin = this.getOrigin(z);\n    var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    var adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n    var tileCoordX = scale * xFromOrigin / tileSize[0];\n    var tileCoordY = scale * yFromOrigin / tileSize[1];\n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  };\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    var origin = this.getOrigin(z);\n    var resolution = this.getResolution(z);\n    var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    var adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n    var tileCoordX = xFromOrigin / tileSize[0];\n    var tileCoordY = yFromOrigin / tileSize[1];\n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  };\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n  };\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  TileGrid.prototype.getTileCoordResolution = function (tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  };\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  TileGrid.prototype.getTileSize = function (z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z];\n    }\n  };\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n   */\n  TileGrid.prototype.getFullTileRange = function (z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;\n    } else {\n      return this.fullTileRanges_[z];\n    }\n  };\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number=} opt_direction If 0, the nearest resolution will be used.\n   *     If 1, the nearest lower resolution will be used. If -1, the nearest\n   *     higher resolution will be used. Default is 0.\n   * @return {number} Z.\n   * @api\n   */\n  TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\n    var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n    return clamp(z, this.minZoom, this.maxZoom);\n  };\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  TileGrid.prototype.calculateTileRanges_ = function (extent) {\n    var length = this.resolutions_.length;\n    var fullTileRanges = new Array(length);\n    for (var z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  };\n  return TileGrid;\n}();\nexport default TileGrid;\n", "/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, get as getProjection } from './proj.js';\nimport { containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth } from './extent.js';\nimport { toSize } from './size.js';\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  var tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  var z = tileCoord[0];\n  var center = tileGrid.getTileCoordCenter(tileCoord);\n  var projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n  var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: opt_tileSize\n  });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions=} opt_options Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n  var xyzOptions = opt_options || {};\n  var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n  var gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)\n  };\n  return new TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number=} opt_maxResolution Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n  var height = getHeight(extent);\n  var width = getWidth(extent);\n  var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n  var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);\n  var length = maxZoom + 1;\n  var resolutions = new Array(length);\n  for (var z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n  var extent = extentFromProjection(projection);\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  var extent = projection.getExtent();\n  if (!extent) {\n    var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport { abstract } from '../util.js';\nimport { assert } from '../asserts.js';\nimport { equivalent } from '../proj.js';\nimport { getKeyZXY, withinExtentAndZ } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection, wrapX } from '../tilegrid.js';\nimport { scale as scaleSize, toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio]\n * @property {import(\"../proj.js\").ProjectionLike} [projection]\n * @property {import(\"./State.js\").default} [state]\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n * @property {number} [zDirection=0]\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nvar TileSource = /** @class */function (_super) {\n  __extends(TileSource, _super);\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  function TileSource(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n    /**\n     * @protected\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n    var tileSize = [256, 256];\n    var tileGrid = options.tileGrid;\n    if (tileGrid) {\n      toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);\n    }\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n    _this.tileCache = new TileCache(options.cacheSize || 0);\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    _this.tmpSize = [0, 0];\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.key_ = options.key || '';\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    _this.tileOptions = {\n      transition: options.transition\n    };\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number}\n     */\n    _this.zDirection = options.zDirection ? options.zDirection : 0;\n    return _this;\n  }\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  TileSource.prototype.canExpireCache = function () {\n    return this.tileCache.canExpireCache();\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  TileSource.prototype.expireCache = function (projection, usedTiles) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n    var covered = true;\n    var tile, tileCoordKey, loaded;\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!import(\"../Tile.js\").default} */tileCache.get(tileCoordKey);\n          loaded = tile.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  TileSource.prototype.getGutterForProjection = function (projection) {\n    return 0;\n  };\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  TileSource.prototype.getKey = function () {\n    return this.key_;\n  };\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  TileSource.prototype.setKey = function (key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  TileSource.prototype.getOpaque = function (projection) {\n    return this.opaque_;\n  };\n  /**\n   * @return {Array<number>} Resolutions.\n   */\n  TileSource.prototype.getResolutions = function () {\n    return this.tileGrid.getResolutions();\n  };\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    return abstract();\n  };\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @api\n   */\n  TileSource.prototype.getTileGrid = function () {\n    return this.tileGrid;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  TileSource.prototype.getTileGridForProjection = function (projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n  TileSource.prototype.getTileCacheForProjection = function (projection) {\n    assert(equivalent(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n    );\n    return this.tileCache;\n  };\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  TileSource.prototype.getTilePixelRatio = function (pixelRatio) {\n    return this.tilePixelRatio_;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  };\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default=} opt_projection Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {\n    var projection = opt_projection !== undefined ? opt_projection : this.getProjection();\n    var tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  };\n  /**\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n   * @api\n   */\n  TileSource.prototype.clear = function () {\n    this.tileCache.clear();\n  };\n  TileSource.prototype.refresh = function () {\n    this.clear();\n    _super.prototype.refresh.call(this);\n  };\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  TileSource.prototype.updateCacheSize = function (tileCount, projection) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  };\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  TileSource.prototype.useTile = function (z, x, y, projection) {};\n  return TileSource;\n}(Source);\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nvar TileSourceEvent = /** @class */function (_super) {\n  __extends(TileSourceEvent, _super);\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  function TileSourceEvent(type, tile) {\n    var _this = _super.call(this, type) || this;\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    _this.tile = tile;\n    return _this;\n  }\n  return TileSourceEvent;\n}(Event);\nexport { TileSourceEvent };\nexport default TileSource;\n", "/**\n * @module ol/tileurlfunction\n */\nimport { assert } from './asserts.js';\nimport { modulo } from './math.js';\nimport { hash as tileCoordHash } from './tilecoord.js';\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  var zRegEx = /\\{z\\}/g;\n  var xRegEx = /\\{x\\}/g;\n  var yRegEx = /\\{y\\}/g;\n  var dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function () {\n          var z = tileCoord[0];\n          var range = tileGrid.getFullTileRange(z);\n          assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n          var y = range.getHeight() - tileCoord[2] - 1;\n          return y.toString();\n        });\n      }\n    }\n  );\n}\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  var len = templates.length;\n  var tileUrlFunctions = new Array(len);\n  for (var i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        var h = tileCoordHash(tileCoord);\n        var index = modulo(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  var urls = [];\n  var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    var startCharCode = match[1].charCodeAt(0);\n    var stopCharCode = match[2].charCodeAt(0);\n    var charCode = void 0;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    var stop_1 = parseInt(match[2], 10);\n    for (var i = parseInt(match[1], 10); i <= stop_1; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { createFromTemplates, expandUrl } from '../tileurlfunction.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection]\n * @property {import(\"./State.js\").default} [state]\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction\n * @property {number} [tilePixelRatio]\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction]\n * @property {string} [url]\n * @property {Array<string>} [urls]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n * @property {number} [zDirection=0]\n */\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nvar UrlTile = /** @class */function (_super) {\n  __extends(UrlTile, _super);\n  /**\n   * @param {Options} options Image tile options.\n   */\n  function UrlTile(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    _this.tileLoadFunction = options.tileLoadFunction;\n    if (options.tileUrlFunction) {\n      _this.tileUrlFunction = options.tileUrlFunction;\n    }\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    _this.urls = null;\n    if (options.urls) {\n      _this.setUrls(options.urls);\n    } else if (options.url) {\n      _this.setUrl(options.url);\n    }\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    _this.tileLoadingKeys_ = {};\n    return _this;\n  }\n  /**\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  UrlTile.prototype.getTileLoadFunction = function () {\n    return this.tileLoadFunction;\n  };\n  /**\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  UrlTile.prototype.getTileUrlFunction = function () {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;\n  };\n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  UrlTile.prototype.getUrls = function () {\n    return this.urls;\n  };\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  UrlTile.prototype.handleTileChange = function (event) {\n    var tile = /** @type {import(\"../Tile.js\").default} */event.target;\n    var uid = getUid(tile);\n    var tileState = tile.getState();\n    var type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  };\n  /**\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  };\n  /**\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string=} key Optional new tile key for the source.\n   * @api\n   */\n  UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  };\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  UrlTile.prototype.setUrl = function (url) {\n    var urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  };\n  /**\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  UrlTile.prototype.setUrls = function (urls) {\n    this.urls = urls;\n    var key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  };\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {\n    return undefined;\n  };\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n  UrlTile.prototype.useTile = function (z, x, y) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n  return UrlTile;\n}(TileSource);\nexport default UrlTile;\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/TileImage\n */\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport { ENABLE_RASTER_REPROJECTION } from '../reproj/common.js';\nimport { IMAGE_SMOOTHING_DISABLED } from './common.js';\nimport { equivalent, get as getProjection } from '../proj.js';\nimport { getKey, getKeyZXY } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection } from '../tilegrid.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar TileImage = /** @class */function (_super) {\n  __extends(TileImage, _super);\n  /**\n   * @param {!Options} options Image tile options.\n   */\n  function TileImage(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection\n    }) || this;\n    /**\n     * @protected\n     * @type {?string}\n     */\n    _this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    _this.tileClass = options.tileClass !== undefined ? options.tileClass : ImageTile;\n    /**\n     * @protected\n     * @type {!Object<string, TileCache>}\n     */\n    _this.tileCacheForProjection = {};\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    _this.tileGridForProjection = {};\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n    /**\n     * @private\n     * @type {object|undefined}\n     */\n    _this.contextOptions_ = options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.renderReprojectionEdges_ = false;\n    return _this;\n  }\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  TileImage.prototype.canExpireCache = function () {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return _super.prototype.canExpireCache.call(this);\n    }\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (var key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  TileImage.prototype.expireCache = function (projection, usedTiles) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      _super.prototype.expireCache.call(this, projection, usedTiles);\n      return;\n    }\n    var usedTileCache = this.getTileCacheForProjection(projection);\n    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n    for (var id in this.tileCacheForProjection) {\n      var tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  };\n  /**\n   * @return {Object|undefined} Context options.\n   */\n  TileImage.prototype.getContextOptions = function () {\n    return this.contextOptions_;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  TileImage.prototype.getGutterForProjection = function (projection) {\n    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n      return 0;\n    } else {\n      return this.getGutter();\n    }\n  };\n  /**\n   * @return {number} Gutter.\n   */\n  TileImage.prototype.getGutter = function () {\n    return 0;\n  };\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  TileImage.prototype.getKey = function () {\n    return _super.prototype.getKey.call(this) + (this.contextOptions_ ? '\\n' + JSON.stringify(this.contextOptions_) : '');\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  TileImage.prototype.getOpaque = function (projection) {\n    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n      return false;\n    } else {\n      return _super.prototype.getOpaque.call(this, projection);\n    }\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  TileImage.prototype.getTileGridForProjection = function (projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return _super.prototype.getTileGridForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = getTileGridForProjection(projection);\n      }\n      return this.tileGridForProjection[projKey];\n    }\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   */\n  TileImage.prototype.getTileCacheForProjection = function (projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return _super.prototype.getTileCacheForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);\n      }\n      return this.tileCacheForProjection[projKey];\n    }\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @private\n   */\n  TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;\n    var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);\n    tile.key = key;\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var sourceProjection = this.getProjection();\n    if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {\n      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\n    } else {\n      var cache = this.getTileCacheForProjection(projection);\n      var tileCoord = [z, x, y];\n      var tile = void 0;\n      var tileCoordKey = getKey(tileCoord);\n      if (cache.containsKey(tileCoordKey)) {\n        tile = cache.get(tileCoordKey);\n      }\n      var key = this.getKey();\n      if (tile && tile.key == key) {\n        return tile;\n      } else {\n        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        var targetTileGrid = this.getTileGridForProjection(projection);\n        var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {\n          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n        }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.contextOptions_);\n        newTile.key = key;\n        if (tile) {\n          newTile.interimTile = tile;\n          newTile.refreshInterimChain();\n          cache.replace(tileCoordKey, newTile);\n        } else {\n          cache.set(tileCoordKey, newTile);\n        }\n        return newTile;\n      }\n    }\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @protected\n   */\n  TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {\n    var tile = null;\n    var tileCoordKey = getKeyZXY(z, x, y);\n    var key = this.getKey();\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile);\n    } else {\n      tile = this.tileCache.get(tileCoordKey);\n      if (tile.key != key) {\n        // The source's params changed. If the tile has an interim tile and if we\n        // can use it then we use it. Otherwise we create a new tile.  In both\n        // cases we attempt to assign an interim tile to the new tile.\n        var interimTile = tile;\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n        //make the new tile the head of the list,\n        if (interimTile.getState() == TileState.IDLE) {\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n          tile.interimTile = interimTile.interimTile;\n        } else {\n          tile.interimTile = interimTile;\n        }\n        tile.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile);\n      }\n    }\n    return tile;\n  };\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  TileImage.prototype.setRenderReprojectionEdges = function (render) {\n    if (!ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    for (var id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n    this.changed();\n  };\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {\n    if (ENABLE_RASTER_REPROJECTION) {\n      var proj = getProjection(projection);\n      if (proj) {\n        var projKey = getUid(proj);\n        if (!(projKey in this.tileGridForProjection)) {\n          this.tileGridForProjection[projKey] = tilegrid;\n        }\n      }\n    }\n  };\n  return TileImage;\n}(UrlTile);\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */imageTile.getImage().src = src;\n}\nexport default TileImage;\n", "/**\n * @module ol/source/XYZ\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport TileImage from './TileImage.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Not used if `tileGrid` is provided.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get\n * tile URL given a tile coordinate and the projection.\n * Required if `url` or `urls` are not provided.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n * may be used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case\n * a `tileUrlFunction` can be used, such as:\n * ```js\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';\n *  }\n * ```\n * @api\n */\nvar XYZ = /** @class */function (_super) {\n  __extends(XYZ, _super);\n  /**\n   * @param {Options=} opt_options XYZ options.\n   */\n  function XYZ(opt_options) {\n    var _this = this;\n    var options = opt_options || {};\n    var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';\n    var tileGrid = options.tileGrid !== undefined ? options.tileGrid : createXYZ({\n      extent: extentFromProjection(projection),\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      opaque: options.opaque,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection\n    }) || this;\n    return _this;\n  }\n  return XYZ;\n}(TileImage);\nexport default XYZ;\n", "/**\n * @module ol/source/OSM\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport XYZ from './XYZ.js';\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nexport var ATTRIBUTION = '&#169; ' + '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">OpenStreetMap</a> ' + 'contributors.';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {number} [maxZoom=19] Max zoom.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n * @api\n */\nvar OSM = /** @class */function (_super) {\n  __extends(OSM, _super);\n  /**\n   * @param {Options=} [opt_options] Open Street Map options.\n   */\n  function OSM(opt_options) {\n    var _this = this;\n    var options = opt_options || {};\n    var attributions;\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n    var url = options.url !== undefined ? options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n    _this = _super.call(this, {\n      attributions: attributions,\n      attributionsCollapsible: false,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      opaque: options.opaque !== undefined ? options.opaque : true,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      transition: options.transition,\n      url: url,\n      wrapX: options.wrapX\n    }) || this;\n    return _this;\n  }\n  return OSM;\n}(XYZ);\nexport default OSM;\n"],
  "mappings": "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",
  "names": ["Triangulation", "d", "b", "ReprojTile", "state", "Tile_default", "TileGrid", "createOrUpdate", "scale", "__extends", "d", "b", "TileSource", "TileSourceEvent", "Tile_default", "__extends", "d", "b", "UrlTile", "Tile_default", "__extends", "d", "b", "TileImage", "Tile_default", "z", "x", "y", "pixelRatio", "render", "__extends", "d", "b", "XYZ", "__extends", "d", "b", "OSM"]
}
