{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/proj/Units.js", "../../../../../../node_modules/ol/proj/Projection.js", "../../../../../../node_modules/ol/proj/epsg3857.js", "../../../../../../node_modules/ol/proj/epsg4326.js", "../../../../../../node_modules/ol/proj/projections.js", "../../../../../../node_modules/ol/proj/transforms.js", "../../../../../../node_modules/ol/sphere.js", "../../../../../../node_modules/ol/string.js", "../../../../../../node_modules/ol/coordinate.js", "../../../../../../node_modules/ol/proj.js"],
  "sourcesContent": ["/**\n * @module ol/proj/Units\n */\n/**\n * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or\n * `'us-ft'`.\n * @enum {string}\n */\nvar Units = {\n  /**\n   * Degrees\n   * @api\n   */\n  DEGREES: 'degrees',\n  /**\n   * Feet\n   * @api\n   */\n  FEET: 'ft',\n  /**\n   * Meters\n   * @api\n   */\n  METERS: 'm',\n  /**\n   * Pixels\n   * @api\n   */\n  PIXELS: 'pixels',\n  /**\n   * Tile Pixels\n   * @api\n   */\n  TILE_PIXELS: 'tile-pixels',\n  /**\n   * US Feet\n   * @api\n   */\n  USFEET: 'us-ft'\n};\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object<Units, number>}\n * @api\n */\nexport var METERS_PER_UNIT = {};\n// use the radius of the Normal sphere\nMETERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;\nMETERS_PER_UNIT[Units.FEET] = 0.3048;\nMETERS_PER_UNIT[Units.METERS] = 1;\nMETERS_PER_UNIT[Units.USFEET] = 1200 / 3937;\nexport default Units;\n", "/**\n * @module ol/proj/Projection\n */\nimport { METERS_PER_UNIT } from './Units.js';\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").default|string} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `{number}` view resolution and an `{import(\"../coordinate.js\").Coordinate}` as arguments, and returns\n * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj#getPointResolution} function will be used.\n */\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj~get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4~register} function.\n *\n * @api\n */\nvar Projection = /** @class */function () {\n  /**\n   * @param {Options} options Projection options.\n   */\n  function Projection(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n    /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import(\"./Units.js\").default}\n     */\n    this.units_ = /** @type {import(\"./Units.js\").default} */options.units;\n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;\n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n    /**\n     * @private\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.defaultTileGrid_ = null;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  Projection.prototype.canWrapX = function () {\n    return this.canWrapX_;\n  };\n  /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */\n  Projection.prototype.getCode = function () {\n    return this.code_;\n  };\n  /**\n   * Get the validity extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  Projection.prototype.getExtent = function () {\n    return this.extent_;\n  };\n  /**\n   * Get the units of this projection.\n   * @return {import(\"./Units.js\").default} Units.\n   * @api\n   */\n  Projection.prototype.getUnits = function () {\n    return this.units_;\n  };\n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  Projection.prototype.getMetersPerUnit = function () {\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n  };\n  /**\n   * Get the world extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  Projection.prototype.getWorldExtent = function () {\n    return this.worldExtent_;\n  };\n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  Projection.prototype.getAxisOrientation = function () {\n    return this.axisOrientation_;\n  };\n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  Projection.prototype.isGlobal = function () {\n    return this.global_;\n  };\n  /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */\n  Projection.prototype.setGlobal = function (global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  };\n  /**\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n   */\n  Projection.prototype.getDefaultTileGrid = function () {\n    return this.defaultTileGrid_;\n  };\n  /**\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n   */\n  Projection.prototype.setDefaultTileGrid = function (tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  };\n  /**\n   * Set the validity extent for this projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  Projection.prototype.setExtent = function (extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  };\n  /**\n   * Set the world extent for this projection.\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  Projection.prototype.setWorldExtent = function (worldExtent) {\n    this.worldExtent_ = worldExtent;\n  };\n  /**\n   * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}\n   * for this projection.\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n   * @api\n   */\n  Projection.prototype.setGetPointResolution = function (func) {\n    this.getPointResolutionFunc_ = func;\n  };\n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */\n  Projection.prototype.getPointResolutionFunc = function () {\n    return this.getPointResolutionFunc_;\n  };\n  return Projection;\n}();\nexport default Projection;\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/proj/epsg3857\n */\nimport Projection from './Projection.js';\nimport Units from './Units.js';\nimport { cosh } from '../math.js';\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nexport var RADIUS = 6378137;\n/**\n * @const\n * @type {number}\n */\nexport var HALF_SIZE = Math.PI * RADIUS;\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport var WORLD_EXTENT = [-180, -85, 180, 85];\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nexport var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nvar EPSG3857Projection = /** @class */function (_super) {\n  __extends(EPSG3857Projection, _super);\n  /**\n   * @param {string} code Code.\n   */\n  function EPSG3857Projection(code) {\n    return _super.call(this, {\n      code: code,\n      units: Units.METERS,\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function (resolution, point) {\n        return resolution / cosh(point[1] / RADIUS);\n      }\n    }) || this;\n  }\n  return EPSG3857Projection;\n}(Projection);\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport var PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function fromEPSG4326(input, opt_output, opt_dimension) {\n  var length = input.length;\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var output = opt_output;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (var i = 0; i < length; i += dimension) {\n    output[i] = HALF_SIZE * input[i] / 180;\n    var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));\n    if (y > MAX_SAFE_Y) {\n      y = MAX_SAFE_Y;\n    } else if (y < -MAX_SAFE_Y) {\n      y = -MAX_SAFE_Y;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n}\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function toEPSG4326(input, opt_output, opt_dimension) {\n  var length = input.length;\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var output = opt_output;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (var i = 0; i < length; i += dimension) {\n    output[i] = 180 * input[i] / HALF_SIZE;\n    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;\n  }\n  return output;\n}\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/proj/epsg4326\n */\nimport Projection from './Projection.js';\nimport Units from './Units.js';\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nexport var RADIUS = 6378137;\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport var EXTENT = [-180, -90, 180, 90];\n/**\n * @const\n * @type {number}\n */\nexport var METERS_PER_UNIT = Math.PI * RADIUS / 180;\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nvar EPSG4326Projection = /** @class */function (_super) {\n  __extends(EPSG4326Projection, _super);\n  /**\n   * @param {string} code Code.\n   * @param {string=} opt_axisOrientation Axis orientation.\n   */\n  function EPSG4326Projection(code, opt_axisOrientation) {\n    return _super.call(this, {\n      code: code,\n      units: Units.DEGREES,\n      extent: EXTENT,\n      axisOrientation: opt_axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: EXTENT\n    }) || this;\n  }\n  return EPSG4326Projection;\n}(Projection);\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport var PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu')];\n", "/**\n * @module ol/proj/projections\n */\n/**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */\nvar cache = {};\n/**\n * Clear the projections cache.\n */\nexport function clear() {\n  cache = {};\n}\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default} The projection (if cached).\n */\nexport function get(code) {\n  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] || null;\n}\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */\nexport function add(code, projection) {\n  cache[code] = projection;\n}\n", "/**\n * @module ol/proj/transforms\n */\nimport { isEmpty } from '../obj.js';\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nvar transforms = {};\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  var transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  var transform;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n}\n", "/**\n * @module ol/sphere\n */\nimport GeometryType from './geom/GeometryType.js';\nimport { toDegrees, toRadians } from './math.js';\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport var DEFAULT_RADIUS = 6371008.8;\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = toRadians(c1[1]);\n  var lat2 = toRadians(c2[1]);\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  var length = 0;\n  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  var type = geometry.getType();\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  var length = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT:\n      {\n        break;\n      }\n    case GeometryType.LINE_STRING:\n    case GeometryType.LINEAR_RING:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        length = getLengthInternal(coordinates, radius);\n        break;\n      }\n    case GeometryType.MULTI_LINE_STRING:\n    case GeometryType.POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          length += getLengthInternal(coordinates[i], radius);\n        }\n        break;\n      }\n    case GeometryType.MULTI_POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          for (j = 0, jj = coords.length; j < jj; ++j) {\n            length += getLengthInternal(coords[j], radius);\n          }\n        }\n        break;\n      }\n    case GeometryType.GEOMETRY_COLLECTION:\n      {\n        var geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */geometry.getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          length += getLength(geometries[i], opt_options);\n        }\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n  return length;\n}\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  var area = 0;\n  var len = coordinates.length;\n  var x1 = coordinates[len - 1][0];\n  var y1 = coordinates[len - 1][1];\n  for (var i = 0; i < len; i++) {\n    var x2 = coordinates[i][0];\n    var y2 = coordinates[i][1];\n    area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * radius * radius / 2.0;\n}\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  var type = geometry.getType();\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  var area = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT:\n    case GeometryType.LINE_STRING:\n    case GeometryType.MULTI_LINE_STRING:\n    case GeometryType.LINEAR_RING:\n      {\n        break;\n      }\n    case GeometryType.POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/Polygon.js\").default} */geometry.getCoordinates();\n        area = Math.abs(getAreaInternal(coordinates[0], radius));\n        for (i = 1, ii = coordinates.length; i < ii; ++i) {\n          area -= Math.abs(getAreaInternal(coordinates[i], radius));\n        }\n        break;\n      }\n    case GeometryType.MULTI_POLYGON:\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          area += Math.abs(getAreaInternal(coords[0], radius));\n          for (j = 1, jj = coords.length; j < jj; ++j) {\n            area -= Math.abs(getAreaInternal(coords[j], radius));\n          }\n        }\n        break;\n      }\n    case GeometryType.GEOMETRY_COLLECTION:\n      {\n        var geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */geometry.getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          area += getArea(geometries[i], opt_options);\n        }\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n  return area;\n}\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = toRadians(c1[1]);\n  var lon1 = toRadians(c1[0]);\n  var dByR = distance / radius;\n  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [toDegrees(lon), toDegrees(lat)];\n}\n", "/**\n * @module ol/string\n */\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)\n * @returns {string} Formatted string\n */\nexport function padNumber(number, width, opt_precision) {\n  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;\n  var decimal = numberString.indexOf('.');\n  decimal = decimal === -1 ? numberString.length : decimal;\n  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;\n}\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @returns {number} Value\n */\nexport function compareVersions(v1, v2) {\n  var s1 = ('' + v1).split('.');\n  var s2 = ('' + v2).split('.');\n  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {\n    var n1 = parseInt(s1[i] || '0', 10);\n    var n2 = parseInt(s2[i] || '0', 10);\n    if (n1 > n2) {\n      return 1;\n    }\n    if (n2 > n1) {\n      return -1;\n    }\n  }\n  return 0;\n}\n", "/**\n * @module ol/coordinate\n */\nimport { getWidth } from './extent.js';\nimport { modulo } from './math.js';\nimport { padNumber } from './string.js';\n/**\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n  coordinate[0] += +delta[0];\n  coordinate[1] += +delta[1];\n  return coordinate;\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n  var r = circle.getRadius();\n  var center = circle.getCenter();\n  var x0 = center[0];\n  var y0 = center[1];\n  var x1 = coordinate[0];\n  var y1 = coordinate[1];\n  var dx = x1 - x0;\n  var dy = y1 - y0;\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n  var d = Math.sqrt(dx * dx + dy * dy);\n  var x = x0 + r * dx / d;\n  var y = y0 + r * dy / d;\n  return [x, y];\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n  var x0 = coordinate[0];\n  var y0 = coordinate[1];\n  var start = segment[0];\n  var end = segment[1];\n  var x1 = start[0];\n  var y1 = start[1];\n  var x2 = end[0];\n  var y2 = end[1];\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  var x, y;\n  if (along <= 0) {\n    x = x1;\n    y = y1;\n  } else if (along >= 1) {\n    x = x2;\n    y = y2;\n  } else {\n    x = x1 + along * dx;\n    y = y1 + along * dy;\n  }\n  return [x, y];\n}\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY();\n *     var out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY(2);\n *     var out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(opt_fractionDigits) {\n  return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n      return toStringXY(coordinate, opt_fractionDigits);\n    }\n  );\n}\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {\n  var normalizedDegrees = modulo(degrees + 180, 360) - 180;\n  var x = Math.abs(3600 * normalizedDegrees);\n  var dflPrecision = opt_fractionDigits || 0;\n  var precision = Math.pow(10, dflPrecision);\n  var deg = Math.floor(x / 3600);\n  var min = Math.floor((x - deg * 3600) / 60);\n  var sec = x - deg * 3600 - min * 60;\n  sec = Math.ceil(sec * precision) / precision;\n  if (sec >= 60) {\n    sec = 0;\n    min += 1;\n  }\n  if (min >= 60) {\n    min = 0;\n    deg += 1;\n  }\n  return deg + '\\u00b0 ' + padNumber(min, 2) + '\\u2032 ' + padNumber(sec, 2, dflPrecision) + '\\u2033' + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));\n}\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, opt_fractionDigits) {\n  if (coordinate) {\n    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));\n  } else {\n    return '';\n  }\n}\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n  var equals = true;\n  for (var i = coordinate1.length - 1; i >= 0; --i) {\n    if (coordinate1[i] != coordinate2[i]) {\n      equals = false;\n      break;\n    }\n  }\n  return equals;\n}\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x;\n  coordinate[1] = y;\n  return coordinate;\n}\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n  coordinate[0] *= scale;\n  coordinate[1] *= scale;\n  return coordinate;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n  var dx = coord1[0] - coord2[0];\n  var dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord);\n *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord, 1);\n *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, opt_fractionDigits) {\n  if (coordinate) {\n    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);\n  } else {\n    return '';\n  }\n}\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, opt_fractionDigits) {\n  return format(coordinate, '{x}, {y}', opt_fractionDigits);\n}\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n  if (projection.canWrapX()) {\n    var worldWidth = getWidth(projection.getExtent());\n    var worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n    if (worldsAway) {\n      coordinate[0] -= worldsAway * worldWidth;\n    }\n  }\n  return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number=} opt_sourceExtentWidth Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {\n  var projectionExtent = projection.getExtent();\n  var worldsAway = 0;\n  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {\n    var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);\n    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);\n  }\n  return worldsAway;\n}\n", "/**\n * @module ol/proj\n */\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection} object for the new projection and add it with\n * {@link module:ol/proj~addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj~addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection} with\n * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport Units, { METERS_PER_UNIT } from './proj/Units.js';\nimport { PROJECTIONS as EPSG3857_PROJECTIONS, fromEPSG4326, toEPSG4326 } from './proj/epsg3857.js';\nimport { PROJECTIONS as EPSG4326_PROJECTIONS } from './proj/epsg4326.js';\nimport { add as addProj, clear as clearProj, get as getProj } from './proj/projections.js';\nimport { add as addTransformFunc, clear as clearTransformFuncs, get as getTransformFunc } from './proj/transforms.js';\nimport { applyTransform, getWidth } from './extent.js';\nimport { clamp, modulo } from './math.js';\nimport { getDistance } from './sphere.js';\nimport { getWorldsAway } from './coordinate.js';\n/**\n * A projection as {@link module:ol/proj/Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\nexport { METERS_PER_UNIT };\nexport { Projection };\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, opt_output, opt_dimension) {\n  var output;\n  if (opt_output !== undefined) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, opt_output, opt_dimension) {\n  if (opt_output !== undefined && input !== opt_output) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    input = opt_output;\n  }\n  return input;\n}\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n  return typeof projectionLike === 'string' ? getProj(/** @type {string} */projectionLike) : /** @type {Projection} */projectionLike || null;\n}\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the 'point' pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").default=} opt_units Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, opt_units) {\n  projection = get(projection);\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (opt_units && opt_units !== projection.getUnits()) {\n      var metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[opt_units];\n      }\n    }\n  } else {\n    var units = projection.getUnits();\n    if (units == Units.DEGREES && !opt_units || opt_units == Units.DEGREES) {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      var toEPSG4326_1 = getTransformFromProjections(projection, get('EPSG:4326'));\n      if (toEPSG4326_1 === identityTransform && units !== Units.DEGREES) {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];\n        vertices = toEPSG4326_1(vertices, vertices, 2);\n        var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      var metersPerUnit = opt_units ? METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return get(projection);\n  } else {\n    return /** @type {Projection} */projection;\n  }\n}\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>=} opt_output Output.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n      var output = opt_output !== undefined ? opt_output : new Array(length);\n      for (var i = 0; i < length; i += dimension) {\n        var point = coordTransform([input[i], input[i + 1]]);\n        output[i] = point[0];\n        output[i + 1] = point[1];\n        for (var j = dimension - 1; j >= 2; --j) {\n          output[i + j] = input[i + j];\n        }\n      }\n      return output;\n    }\n  );\n}\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  var sourceProj = get(source);\n  var destProj = get(destination);\n  addTransformFunc(sourceProj, destProj, createTransformFromCoordinateTransform(forward));\n  addTransformFunc(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));\n}\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike=} opt_projection Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, opt_projection) {\n  return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n}\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike=} opt_projection Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, opt_projection) {\n  var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n  var lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFunc = getTransformFromProjections(projection1, projection2);\n    return transformFunc === cloneTransform && equalUnits;\n  }\n}\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nexport function getTransformFromProjections(sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n  var transformFunc = getTransformFunc(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n  var sourceProjection = get(source);\n  var destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj~transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n  var transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number=} opt_stops Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, opt_stops) {\n  var transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, opt_stops);\n}\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(point, sourceProjection, destinationProjection) {\n  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);\n  return transformFunc(point);\n}\n/**\n * @type {?Projection}\n */\nvar userProjection = null;\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @param {ProjectionLike} projection The user projection.\n */\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n/**\n * Clear the user projection if set.  Note that this method is not yet a part of\n * the stable API.  Support for user projections is not yet complete and should\n * be considered experimental.\n */\nexport function clearUserProjection() {\n  userProjection = null;\n}\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @returns {?Projection} The user projection (or null if not set).\n */\nexport function getUserProjection() {\n  return userProjection;\n}\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.  Note that this\n * method is not yet a part of the stable API.  Support for user projections is\n * not yet complete and should be considered experimental.\n */\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @returns {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @returns {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @returns {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @returns {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destiation).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destiation).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    var sourceX = coord[0];\n    var sourceY = coord[1];\n    var transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      var sourceExtent = sourceProj.getExtent();\n      var sourceExtentWidth = getWidth(sourceExtent);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        sourceX = sourceX - worldsAway * sourceExtentWidth;\n      }\n      sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);\n      sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);\n      transformed = transform([sourceX, sourceY]);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(EPSG4326_PROJECTIONS, EPSG3857_PROJECTIONS, fromEPSG4326, toEPSG4326);\n}\naddCommon();\n"],
  "mappings": "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",
  "names": ["Projection", "d", "b", "EPSG3857Projection", "__extends", "d", "b", "RADIUS", "EXTENT", "METERS_PER_UNIT", "EPSG4326Projection", "PROJECTIONS", "clear", "add", "get", "transform", "distance", "add", "equals", "scale", "add", "get", "clear", "transform", "PROJECTIONS"]
}
