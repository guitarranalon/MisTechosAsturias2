{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/Geolocation.js", "../../../../../../node_modules/ol/render.js", "../../../../../../node_modules/ol/geom/flat/geodesic.js", "../../../../../../node_modules/ol/layer/Graticule.js", "../../../../../../node_modules/ol/ImageCanvas.js", "../../../../../../node_modules/ol/VectorRenderTile.js", "../../../../../../node_modules/ol/VectorTile.js"],
  "sourcesContent": ["var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/Geolocation\n */\nimport BaseEvent from './events/Event.js';\nimport BaseObject, { getChangeEventType } from './Object.js';\nimport EventType from './events/EventType.js';\nimport { circular as circularPolygon } from './geom/Polygon.js';\nimport { get as getProjection, getTransformFromProjections, identityTransform } from './proj.js';\nimport { toRadians } from './math.js';\n/**\n * @enum {string}\n */\nvar Property = {\n  ACCURACY: 'accuracy',\n  ACCURACY_GEOMETRY: 'accuracyGeometry',\n  ALTITUDE: 'altitude',\n  ALTITUDE_ACCURACY: 'altitudeAccuracy',\n  HEADING: 'heading',\n  POSITION: 'position',\n  PROJECTION: 'projection',\n  SPEED: 'speed',\n  TRACKING: 'tracking',\n  TRACKING_OPTIONS: 'trackingOptions'\n};\n/**\n * @classdesc\n * Events emitted on Geolocation error.\n */\nvar GeolocationError = /** @class */function (_super) {\n  __extends(GeolocationError, _super);\n  /**\n   * @param {GeolocationPositionError} error error object.\n   */\n  function GeolocationError(error) {\n    var _this = _super.call(this, EventType.ERROR) || this;\n    /**\n     * @type {number}\n     */\n    _this.code = error.code;\n    /**\n     * @type {string}\n     */\n    _this.message = error.message;\n    return _this;\n  }\n  return GeolocationError;\n}(BaseEvent);\n/**\n * @typedef {Object} Options\n * @property {boolean} [tracking=false] Start Tracking right after\n * instantiation.\n * @property {PositionOptions} [trackingOptions] Tracking options.\n * See http://www.w3.org/TR/geolocation-API/#position_options_interface.\n * @property {import(\"./proj.js\").ProjectionLike} [projection] The projection the position\n * is reported in.\n */\n/**\n * @classdesc\n * Helper class for providing HTML5 Geolocation capabilities.\n * The [Geolocation API](http://www.w3.org/TR/geolocation-API/)\n * is used to locate a user's position.\n *\n * To get notified of position changes, register a listener for the generic\n * `change` event on your instance of {@link module:ol/Geolocation~Geolocation}.\n *\n * Example:\n *\n *     var geolocation = new Geolocation({\n *       // take the projection to use from the map's view\n *       projection: view.getProjection()\n *     });\n *     // listen to changes in position\n *     geolocation.on('change', function(evt) {\n *       window.console.log(geolocation.getPosition());\n *     });\n *\n * @fires module:ol/events/Event~BaseEvent#event:error\n * @api\n */\nvar Geolocation = /** @class */function (_super) {\n  __extends(Geolocation, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  function Geolocation(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options || {};\n    /**\n     * The unprojected (EPSG:4326) device position.\n     * @private\n     * @type {?import(\"./coordinate.js\").Coordinate}\n     */\n    _this.position_ = null;\n    /**\n     * @private\n     * @type {import(\"./proj.js\").TransformFunction}\n     */\n    _this.transform_ = identityTransform;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    _this.watchId_ = undefined;\n    _this.addEventListener(getChangeEventType(Property.PROJECTION), _this.handleProjectionChanged_);\n    _this.addEventListener(getChangeEventType(Property.TRACKING), _this.handleTrackingChanged_);\n    if (options.projection !== undefined) {\n      _this.setProjection(options.projection);\n    }\n    if (options.trackingOptions !== undefined) {\n      _this.setTrackingOptions(options.trackingOptions);\n    }\n    _this.setTracking(options.tracking !== undefined ? options.tracking : false);\n    return _this;\n  }\n  /**\n   * Clean up.\n   */\n  Geolocation.prototype.disposeInternal = function () {\n    this.setTracking(false);\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @private\n   */\n  Geolocation.prototype.handleProjectionChanged_ = function () {\n    var projection = this.getProjection();\n    if (projection) {\n      this.transform_ = getTransformFromProjections(getProjection('EPSG:4326'), projection);\n      if (this.position_) {\n        this.set(Property.POSITION, this.transform_(this.position_));\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  Geolocation.prototype.handleTrackingChanged_ = function () {\n    if ('geolocation' in navigator) {\n      var tracking = this.getTracking();\n      if (tracking && this.watchId_ === undefined) {\n        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());\n      } else if (!tracking && this.watchId_ !== undefined) {\n        navigator.geolocation.clearWatch(this.watchId_);\n        this.watchId_ = undefined;\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {GeolocationPosition} position position event.\n   */\n  Geolocation.prototype.positionChange_ = function (position) {\n    var coords = position.coords;\n    this.set(Property.ACCURACY, coords.accuracy);\n    this.set(Property.ALTITUDE, coords.altitude === null ? undefined : coords.altitude);\n    this.set(Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy);\n    this.set(Property.HEADING, coords.heading === null ? undefined : toRadians(coords.heading));\n    if (!this.position_) {\n      this.position_ = [coords.longitude, coords.latitude];\n    } else {\n      this.position_[0] = coords.longitude;\n      this.position_[1] = coords.latitude;\n    }\n    var projectedPosition = this.transform_(this.position_);\n    this.set(Property.POSITION, projectedPosition);\n    this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);\n    var geometry = circularPolygon(this.position_, coords.accuracy);\n    geometry.applyTransform(this.transform_);\n    this.set(Property.ACCURACY_GEOMETRY, geometry);\n    this.changed();\n  };\n  /**\n   * @private\n   * @param {GeolocationPositionError} error error object.\n   */\n  Geolocation.prototype.positionError_ = function (error) {\n    this.dispatchEvent(new GeolocationError(error));\n  };\n  /**\n   * Get the accuracy of the position in meters.\n   * @return {number|undefined} The accuracy of the position measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getAccuracy = function () {\n    return /** @type {number|undefined} */this.get(Property.ACCURACY);\n  };\n  /**\n   * Get a geometry of the position accuracy.\n   * @return {?import(\"./geom/Polygon.js\").default} A geometry of the position accuracy.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getAccuracyGeometry = function () {\n    return /** @type {?import(\"./geom/Polygon.js\").default} */this.get(Property.ACCURACY_GEOMETRY) || null;\n  };\n  /**\n   * Get the altitude associated with the position.\n   * @return {number|undefined} The altitude of the position in meters above mean\n   *     sea level.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getAltitude = function () {\n    return /** @type {number|undefined} */this.get(Property.ALTITUDE);\n  };\n  /**\n   * Get the altitude accuracy of the position.\n   * @return {number|undefined} The accuracy of the altitude measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getAltitudeAccuracy = function () {\n    return /** @type {number|undefined} */this.get(Property.ALTITUDE_ACCURACY);\n  };\n  /**\n   * Get the heading as radians clockwise from North.\n   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`\n   * is set to `true` in the tracking options.\n   * @return {number|undefined} The heading of the device in radians from north.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getHeading = function () {\n    return /** @type {number|undefined} */this.get(Property.HEADING);\n  };\n  /**\n   * Get the position of the device.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The current position of the device reported\n   *     in the current projection.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getPosition = function () {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */this.get(Property.POSITION);\n  };\n  /**\n   * Get the projection associated with the position.\n   * @return {import(\"./proj/Projection.js\").default|undefined} The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getProjection = function () {\n    return /** @type {import(\"./proj/Projection.js\").default|undefined} */this.get(Property.PROJECTION);\n  };\n  /**\n   * Get the speed in meters per second.\n   * @return {number|undefined} The instantaneous speed of the device in meters\n   *     per second.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getSpeed = function () {\n    return /** @type {number|undefined} */this.get(Property.SPEED);\n  };\n  /**\n   * Determine if the device location is being tracked.\n   * @return {boolean} The device location is being tracked.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getTracking = function () {\n    return /** @type {boolean} */this.get(Property.TRACKING);\n  };\n  /**\n   * Get the tracking options.\n   * See http://www.w3.org/TR/geolocation-API/#position-options.\n   * @return {PositionOptions|undefined} PositionOptions as defined by\n   *     the [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.getTrackingOptions = function () {\n    return /** @type {PositionOptions|undefined} */this.get(Property.TRACKING_OPTIONS);\n  };\n  /**\n   * Set the projection to use for transforming the coordinates.\n   * @param {import(\"./proj.js\").ProjectionLike} projection The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.setProjection = function (projection) {\n    this.set(Property.PROJECTION, getProjection(projection));\n  };\n  /**\n   * Enable or disable tracking.\n   * @param {boolean} tracking Enable tracking.\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.setTracking = function (tracking) {\n    this.set(Property.TRACKING, tracking);\n  };\n  /**\n   * Set the tracking options.\n   * See http://www.w3.org/TR/geolocation-API/#position-options.\n   * @param {PositionOptions} options PositionOptions as defined by the\n   *     [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  Geolocation.prototype.setTrackingOptions = function (options) {\n    this.set(Property.TRACKING_OPTIONS, options);\n  };\n  return Geolocation;\n}(BaseObject);\nexport default Geolocation;\n", "/**\n * @module ol/render\n */\nimport CanvasImmediateRenderer from './render/canvas/Immediate.js';\nimport { DEVICE_PIXEL_RATIO } from './has.js';\nimport { apply as applyTransform, create as createTransform, multiply as multiplyTransform, scale as scaleTransform } from './transform.js';\nimport { getSquaredTolerance } from './renderer/vector.js';\nimport { getTransformFromProjections, getUserProjection } from './proj.js';\n/**\n * @typedef {Object} State\n * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.\n * @property {import(\"./Feature.js\").FeatureLike} feature\n * @property {import(\"./geom/SimpleGeometry.js\").default} geometry\n * @property {number} pixelRatio Pixel ratio used by the layer renderer.\n * @property {number} resolution Resolution that the render batch was created and optimized for.\n * This is not the view's resolution that is being rendered.\n * @property {number} rotation Rotation of the rendered layer in radians.\n */\n/**\n * A function to be used when sorting features before rendering.\n * It takes two instances of {@link module:ol/Feature} or\n * {@link module:ol/render/Feature} and returns a `{number}`.\n *\n * @typedef {function(import(\"./Feature.js\").FeatureLike, import(\"./Feature.js\").FeatureLike):number} OrderFunction\n */\n/**\n * @typedef {Object} ToContextOptions\n * @property {import(\"./size.js\").Size} [size] Desired size of the canvas in css\n * pixels. When provided, both canvas and css size will be set according to the\n * `pixelRatio`. If not provided, the current canvas and css sizes will not be\n * altered.\n * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas\n * pixel to css pixel ratio) for the canvas.\n */\n/**\n * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries\n * to the context's canvas.\n *\n * The units for geometry coordinates are css pixels relative to the top left\n * corner of the canvas element.\n * ```js\n * import {toContext} from 'ol/render';\n * import Fill from 'ol/style/Fill';\n * import Polygon from 'ol/geom/Polygon';\n *\n * var canvas = document.createElement('canvas');\n * var render = toContext(canvas.getContext('2d'),\n *     { size: [100, 100] });\n * render.setFillStrokeStyle(new Fill({ color: blue }));\n * render.drawPolygon(\n *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));\n * ```\n *\n * @param {CanvasRenderingContext2D} context Canvas context.\n * @param {ToContextOptions=} opt_options Options.\n * @return {CanvasImmediateRenderer} Canvas Immediate.\n * @api\n */\nexport function toContext(context, opt_options) {\n  var canvas = context.canvas;\n  var options = opt_options ? opt_options : {};\n  var pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;\n  var size = options.size;\n  if (size) {\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n  }\n  var extent = [0, 0, canvas.width, canvas.height];\n  var transform = scaleTransform(createTransform(), pixelRatio, pixelRatio);\n  return new CanvasImmediateRenderer(context, pixelRatio, extent, transform, 0);\n}\n/**\n * Gets a vector context for drawing to the event's canvas.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @returns {CanvasImmediateRenderer} Vector context.\n * @api\n */\nexport function getVectorContext(event) {\n  var frameState = event.frameState;\n  var transform = multiplyTransform(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);\n  var squaredTolerance = getSquaredTolerance(frameState.viewState.resolution, frameState.pixelRatio);\n  var userTransform;\n  var userProjection = getUserProjection();\n  if (userProjection) {\n    userTransform = getTransformFromProjections(userProjection, frameState.viewState.projection);\n  }\n  return new CanvasImmediateRenderer(event.context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation, squaredTolerance, userTransform);\n}\n/**\n * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @param {import(\"./pixel.js\").Pixel} pixel CSS pixel relative to the top-left\n * corner of the map viewport.\n * @returns {import(\"./pixel.js\").Pixel} Pixel on the event's canvas context.\n * @api\n */\nexport function getRenderPixel(event, pixel) {\n  var result = pixel.slice(0);\n  applyTransform(event.inversePixelTransform.slice(), result);\n  return result;\n}\n", "/**\n * @module ol/geom/flat/geodesic\n */\nimport { get as getProjection, getTransform } from '../../proj.js';\nimport { squaredSegmentDistance, toDegrees, toRadians } from '../../math.js';\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n  /** @type {Array<number>} */\n  var flatCoordinates = [];\n  var geoA = interpolate(0);\n  var geoB = interpolate(1);\n  var a = transform(geoA);\n  var b = transform(geoB);\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  var geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  var stack = [b, a];\n  /** @type {Array<number>} */\n  var fractionStack = [1, 0];\n  /** @type {!Object<string, boolean>} */\n  var fractions = {};\n  var maxIterations = 1e5;\n  var geoM, m, fracA, fracB, fracM, key;\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop();\n    // Add the a coordinate if it has not been added yet\n    key = fracA.toString();\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    }\n    // Pop the b coordinate off the stack\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop();\n    // Find the m point between the a and b coordinates\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n    if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n  return flatCoordinates;\n}\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n  var geoProjection = getProjection('EPSG:4326');\n  var cosLat1 = Math.cos(toRadians(lat1));\n  var sinLat1 = Math.sin(toRadians(lat1));\n  var cosLat2 = Math.cos(toRadians(lat2));\n  var sinLat2 = Math.sin(toRadians(lat2));\n  var cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  var sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    if (1 <= d) {\n      return [lon2, lat2];\n    }\n    var D = frac * Math.acos(d);\n    var cosD = Math.cos(D);\n    var sinD = Math.sin(D);\n    var y = sinDeltaLon * cosLat2;\n    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n    var theta = Math.atan2(y, x);\n    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n    var lon = toRadians(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n  }, getTransform(geoProjection, projection), squaredTolerance);\n}\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon, lat1 + (lat2 - lat1) * frac];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon1 + (lon2 - lon1) * frac, lat];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { applyTransform, approximatelyEquals, containsCoordinate, containsExtent, equals, getCenter, getHeight, getIntersection, getWidth, intersects, isEmpty, wrapX as wrapExtentX } from '../extent.js';\nimport { assign } from '../obj.js';\nimport { clamp } from '../math.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform } from '../proj.js';\nimport { getVectorContext } from '../render.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nvar DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)'\n});\n/**\n * @type {Array<number>}\n * @private\n */\nvar INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom\n * @property {string} text\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle='rgba(0,0,0,0.2)'] The\n * stroke style to use for drawing the graticule. If not provided, a not fully\n * opaque black will be used.\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n */\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\nvar Graticule = /** @class */function (_super) {\n  __extends(Graticule, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  function Graticule(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n      renderBuffer: 0\n    }, options);\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    _this = _super.call(this, baseOptions) || this;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    _this.projection_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLat_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLon_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLat_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLon_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxX_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxY_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minX_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minY_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.meridians_ = [];\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.parallels_ = [];\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.fromLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.toLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.projectionCenterLonLat_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomRight_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topRight_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.meridiansLabels_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.parallelsLabels_ = null;\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'EW') : options.lonLabelFormatter;\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'NS') : options.latLabelFormatter;\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.lonLabelStyleBase_ = new Style({\n        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.lonLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(_this);\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.latLabelStyleBase_ = new Style({\n        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'right',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.latLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(_this);\n      _this.meridiansLabels_ = [];\n      _this.parallelsLabels_ = [];\n      _this.addEventListener(EventType.POSTRENDER, _this.drawLabels_.bind(_this));\n    }\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS;\n    // use a source with a custom loader for lines & text\n    _this.setSource(new VectorSource({\n      loader: _this.loaderFunction.bind(_this),\n      strategy: _this.strategyFunction.bind(_this),\n      features: new Collection(),\n      overlaps: false,\n      useSpatialIndex: false,\n      wrapX: options.wrapX\n    }));\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    _this.featurePool_ = [];\n    /**\n     * @type {Style}\n     * @private\n     */\n    _this.lineStyle_ = new Style({\n      stroke: _this.strokeStyle_\n    });\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    _this.loadedExtent_ = null;\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     */\n    _this.renderedExtent_ = null;\n    _this.setRenderOrder(null);\n    return _this;\n  }\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  Graticule.prototype.strategyFunction = function (extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    var realWorldExtent = extent.slice();\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n    if (this.loadedExtent_) {\n      if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n    return [realWorldExtent];\n  };\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n  Graticule.prototype.loaderFunction = function (extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    var source = this.getSource();\n    // only consider the intersection between our own extent & the requested one\n    var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];\n    var renderExtent = getIntersection(layerExtent, extent);\n    if (this.renderedExtent_ && equals(this.renderedExtent_, renderExtent)) {\n      return;\n    }\n    this.renderedExtent_ = renderExtent;\n    // bail out if nothing to render\n    if (isEmpty(renderExtent)) {\n      return;\n    }\n    // update projection info\n    var center = getCenter(renderExtent);\n    var squaredTolerance = resolution * resolution / 4;\n    var updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n    // first make sure we have enough features in the pool\n    var featureCount = this.meridians_.length + this.parallels_.length;\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n    var feature;\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n    var featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    var poolIndex = 0;\n    // add features for the lines & labels\n    var i, l;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {\n    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        var text = this.lonLabelFormatter_(lon);\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {\n    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        var text = this.latLabelFormatter_(lat);\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  };\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n  Graticule.prototype.drawLabels_ = function (event) {\n    var rotation = event.frameState.viewState.rotation;\n    var extent = event.frameState.extent;\n    var rotationCenter = getCenter(extent);\n    var rotationExtent = extent;\n    if (rotation) {\n      var width = getWidth(extent);\n      var height = getHeight(extent);\n      var cr = Math.abs(Math.cos(rotation));\n      var sr = Math.abs(Math.sin(rotation));\n      var unrotatedWidth = (sr * height - cr * width) / (sr * sr - cr * cr);\n      var unrotatedHeight = (sr * width - cr * height) / (sr * sr - cr * cr);\n      rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];\n    }\n    var startWorld = 0;\n    var endWorld = 0;\n    var labelsAtStart = this.latLabelPosition_ < 0.5;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = getWidth(projectionExtent);\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      var inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n    var vectorContext = getVectorContext(event);\n    for (var world = startWorld; world <= endWorld; ++world) {\n      var poolIndex = this.meridians_.length + this.parallels_.length;\n      var feature = void 0,\n        index = void 0,\n        l = void 0,\n        textPoint = void 0;\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          var lineString = this.meridians_[index];\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            var clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n      if (this.parallelsLabels_) {\n        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            var lineString = this.parallels_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              var clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {\n    var interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n    var wrapX = false;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = getWidth(projectionExtent);\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    }\n    // Constrain the center to fit into the extent available to the graticule\n    var validCenterP = [clamp(center[0], this.minX_, this.maxX_), clamp(center[1], this.minY_, this.maxY_)];\n    // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n    var centerLonLat = this.toLonLatTransform_(validCenterP);\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n    var centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    var centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    var maxLines = this.maxLines_;\n    var cnt, idx, lat, lon;\n    // Limit the extent to fit into the extent available to the graticule\n    var validExtentP = extent;\n    if (!wrapX) {\n      validExtentP = [clamp(extent[0], this.minX_, this.maxX_), clamp(extent[1], this.minY_, this.maxY_), clamp(extent[2], this.minX_, this.maxX_), clamp(extent[3], this.minY_, this.maxY_)];\n    }\n    // Transform the extent to get the lon lat ranges for the edges of the extent\n    var validExtent = applyTransform(validExtentP, this.toLonLatTransform_, undefined, 8);\n    var maxLat = validExtent[3];\n    var maxLon = validExtent[2];\n    var minLat = validExtent[1];\n    var minLon = validExtent[0];\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      }\n      // The transformed center may also extend the lon lat ranges used for rendering\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    }\n    // Create meridians\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n    cnt = 0;\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    cnt = 0;\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n    // Create parallels\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  };\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  Graticule.prototype.getInterval_ = function (resolution) {\n    var centerLon = this.projectionCenterLonLat_[0];\n    var centerLat = this.projectionCenterLonLat_[1];\n    var interval = -1;\n    var target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n    var p1 = [];\n    /** @type {Array<number>} **/\n    var p2 = [];\n    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      var delta = clamp(this.intervals_[i] / 2, 0, 90);\n      // Don't attempt to transform latitudes beyond the poles!\n      var clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = this.intervals_[i];\n    }\n    return interval;\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {\n    var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n    var lineString = this.meridians_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n  Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var bottom = 1;\n    var top = flatCoordinates.length - 1;\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n    var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    var clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n    var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);\n    var coordinate = [coordinate0, lat];\n    var point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n  Graticule.prototype.getMeridians = function () {\n    return this.meridians_;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {\n    var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n    var lineString = this.parallels_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n  Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var left = 0;\n    var right = flatCoordinates.length - 2;\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n    var clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    var clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n    var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);\n    var coordinate = [lon, coordinate1];\n    var point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n  Graticule.prototype.getParallels = function () {\n    return this.parallels_;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  Graticule.prototype.updateProjectionInfo_ = function (projection) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    var worldExtent = projection.getWorldExtent();\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n    // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n    var toLonLatTransform = getTransform(projection, epsg4326Projection);\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      var split_1 = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n      this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {\n        var dimension = opt_dimension || 2;\n        var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);\n        for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split_1) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n        return lonLatCoordinates;\n      };\n    }\n    // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    var worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3];\n    // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n    // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n    this.projection_ = projection;\n  };\n  return Graticule;\n}(VectorLayer);\nexport default Graticule;\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/ImageCanvas\n */\nimport ImageBase from './ImageBase.js';\nimport ImageState from './ImageState.js';\n/**\n * A function that is called to trigger asynchronous canvas drawing.  It is\n * called with a \"done\" callback that should be called when drawing is done.\n * If any error occurs during drawing, the \"done\" callback should be called with\n * that error.\n *\n * @typedef {function(function(Error=): void): void} Loader\n */\nvar ImageCanvas = /** @class */function (_super) {\n  __extends(ImageCanvas, _super);\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {Loader=} opt_loader Optional loader function to\n   *     support asynchronous canvas drawing.\n   */\n  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {\n    var _this = this;\n    var state = opt_loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\n    _this = _super.call(this, extent, resolution, pixelRatio, state) || this;\n    /**\n     * Optional canvas loader function.\n     * @type {?Loader}\n     * @private\n     */\n    _this.loader_ = opt_loader !== undefined ? opt_loader : null;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = canvas;\n    /**\n     * @private\n     * @type {?Error}\n     */\n    _this.error_ = null;\n    return _this;\n  }\n  /**\n   * Get any error associated with asynchronous rendering.\n   * @return {?Error} Any error that occurred during rendering.\n   */\n  ImageCanvas.prototype.getError = function () {\n    return this.error_;\n  };\n  /**\n   * Handle async drawing complete.\n   * @param {Error=} err Any error during drawing.\n   * @private\n   */\n  ImageCanvas.prototype.handleLoad_ = function (err) {\n    if (err) {\n      this.error_ = err;\n      this.state = ImageState.ERROR;\n    } else {\n      this.state = ImageState.LOADED;\n    }\n    this.changed();\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n  ImageCanvas.prototype.load = function () {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.loader_(this.handleLoad_.bind(this));\n    }\n  };\n  /**\n   * @return {HTMLCanvasElement} Canvas element.\n   */\n  ImageCanvas.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  return ImageCanvas;\n}(ImageBase);\nexport default ImageCanvas;\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/VectorRenderTile\n */\nimport Tile from './Tile.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { getUid } from './util.js';\n/**\n * @typedef {Object} ReplayState\n * @property {boolean} dirty\n * @property {null|import(\"./render.js\").OrderFunction} renderedRenderOrder\n * @property {number} renderedTileRevision\n * @property {number} renderedResolution\n * @property {number} renderedRevision\n * @property {number} renderedZ\n * @property {number} renderedTileResolution\n * @property {number} renderedTileZ\n */\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nvar canvasPool = [];\nvar VectorRenderTile = /** @class */function (_super) {\n  __extends(VectorRenderTile, _super);\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {import(\"./tilecoord.js\").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.\n   * @param {function(VectorRenderTile):Array<import(\"./VectorTile\").default>} getSourceTiles Function\n   * to get source tiles for this tile.\n   */\n  function VectorRenderTile(tileCoord, state, urlTileCoord, getSourceTiles) {\n    var _this = _super.call(this, tileCoord, state, {\n      transition: 0\n    }) || this;\n    /**\n     * @private\n     * @type {!Object<string, CanvasRenderingContext2D>}\n     */\n    _this.context_ = {};\n    /**\n     * Executor groups by layer uid. Entries are read/written by the renderer.\n     * @type {Object<string, Array<import(\"./render/canvas/ExecutorGroup.js\").default>>}\n     */\n    _this.executorGroups = {};\n    /**\n     * Executor groups for decluttering, by layer uid. Entries are read/written by the renderer.\n     * @type {Object<string, Array<import(\"./render/canvas/ExecutorGroup.js\").default>>}\n     */\n    _this.declutterExecutorGroups = {};\n    /**\n     * Number of loading source tiles. Read/written by the source.\n     * @type {number}\n     */\n    _this.loadingSourceTiles = 0;\n    /**\n     * Tile keys of error source tiles. Read/written by the source.\n     * @type {Object<string, boolean>}\n     */\n    _this.errorSourceTileKeys = {};\n    /**\n     * @type {Object<number, ImageData>}\n     */\n    _this.hitDetectionImageData = {};\n    /**\n     * @private\n     * @type {!Object<string, ReplayState>}\n     */\n    _this.replayState_ = {};\n    /**\n     * @type {Array<import(\"./VectorTile.js\").default>}\n     */\n    _this.sourceTiles = null;\n    /**\n     * @type {number}\n     */\n    _this.wantedResolution;\n    /**\n     * @type {!function():Array<import(\"./VectorTile.js\").default>}\n     */\n    _this.getSourceTiles = getSourceTiles.bind(undefined, _this);\n    /**\n     * z of the source tiles of the last getSourceTiles call.\n     * @type {number}\n     */\n    _this.sourceZ = -1;\n    /**\n     * True when all tiles for this tile's nominal resolution are available.\n     * @type {boolean}\n     */\n    _this.hifi = false;\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord = urlTileCoord;\n    return _this;\n  }\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {CanvasRenderingContext2D} The rendering context.\n   */\n  VectorRenderTile.prototype.getContext = function (layer) {\n    var key = getUid(layer);\n    if (!(key in this.context_)) {\n      this.context_[key] = createCanvasContext2D(1, 1, canvasPool);\n    }\n    return this.context_[key];\n  };\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {boolean} Tile has a rendering context for the given layer.\n   */\n  VectorRenderTile.prototype.hasContext = function (layer) {\n    return getUid(layer) in this.context_;\n  };\n  /**\n   * Get the Canvas for this tile.\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  VectorRenderTile.prototype.getImage = function (layer) {\n    return this.hasContext(layer) ? this.getContext(layer).canvas : null;\n  };\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {ReplayState} The replay state.\n   */\n  VectorRenderTile.prototype.getReplayState = function (layer) {\n    var key = getUid(layer);\n    if (!(key in this.replayState_)) {\n      this.replayState_[key] = {\n        dirty: false,\n        renderedRenderOrder: null,\n        renderedResolution: NaN,\n        renderedRevision: -1,\n        renderedTileResolution: NaN,\n        renderedTileRevision: -1,\n        renderedZ: -1,\n        renderedTileZ: -1\n      };\n    }\n    return this.replayState_[key];\n  };\n  /**\n   * Load the tile.\n   */\n  VectorRenderTile.prototype.load = function () {\n    this.getSourceTiles();\n  };\n  /**\n   * Remove from the cache due to expiry\n   */\n  VectorRenderTile.prototype.release = function () {\n    for (var key in this.context_) {\n      canvasPool.push(this.context_[key].canvas);\n      delete this.context_[key];\n    }\n    _super.prototype.release.call(this);\n  };\n  return VectorRenderTile;\n}(Tile);\nexport default VectorRenderTile;\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/VectorTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nvar VectorTile = /** @class */function (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Data source url.\n   * @param {import(\"./format/Feature.js\").default} format Feature format.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options=} opt_options Tile options.\n   */\n  function VectorTile(tileCoord, state, src, format, tileLoadFunction, opt_options) {\n    var _this = _super.call(this, tileCoord, state, opt_options) || this;\n    /**\n     * Extent of this tile; set by the source.\n     * @type {import(\"./extent.js\").Extent}\n     */\n    _this.extent = null;\n    /**\n     * @private\n     * @type {import(\"./format/Feature.js\").default}\n     */\n    _this.format_ = format;\n    /**\n     * @private\n     * @type {Array<import(\"./Feature.js\").default>}\n     */\n    _this.features_ = null;\n    /**\n     * @private\n     * @type {import(\"./featureloader.js\").FeatureLoader}\n     */\n    _this.loader_;\n    /**\n     * Feature projection of this tile; set by the source.\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n    _this.projection = null;\n    /**\n     * Resolution of this tile; set by the source.\n     * @type {number}\n     */\n    _this.resolution;\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    _this.tileLoadFunction_ = tileLoadFunction;\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.url_ = src;\n    _this.key = src;\n    return _this;\n  }\n  /**\n   * Get the feature format assigned for reading this tile's features.\n   * @return {import(\"./format/Feature.js\").default} Feature format.\n   * @api\n   */\n  VectorTile.prototype.getFormat = function () {\n    return this.format_;\n  };\n  /**\n   * Get the features for this tile. Geometries will be in the view projection.\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  VectorTile.prototype.getFeatures = function () {\n    return this.features_;\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n  VectorTile.prototype.load = function () {\n    if (this.state == TileState.IDLE) {\n      this.setState(TileState.LOADING);\n      this.tileLoadFunction_(this, this.url_);\n      if (this.loader_) {\n        this.loader_(this.extent, this.resolution, this.projection);\n      }\n    }\n  };\n  /**\n   * Handler for successful tile load.\n   * @param {Array<import(\"./Feature.js\").default>} features The loaded features.\n   * @param {import(\"./proj/Projection.js\").default} dataProjection Data projection.\n   */\n  VectorTile.prototype.onLoad = function (features, dataProjection) {\n    this.setFeatures(features);\n  };\n  /**\n   * Handler for tile load errors.\n   */\n  VectorTile.prototype.onError = function () {\n    this.setState(TileState.ERROR);\n  };\n  /**\n   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.\n   * Sets the features for the tile.\n   * @param {Array<import(\"./Feature.js\").default>} features Features.\n   * @api\n   */\n  VectorTile.prototype.setFeatures = function (features) {\n    this.features_ = features;\n    this.setState(TileState.LOADED);\n  };\n  /**\n   * Set the feature loader for reading this tile's features.\n   * @param {import(\"./featureloader.js\").FeatureLoader} loader Feature loader.\n   * @api\n   */\n  VectorTile.prototype.setLoader = function (loader) {\n    this.loader_ = loader;\n  };\n  return VectorTile;\n}(Tile);\nexport default VectorTile;\n"],
  "mappings": "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",
  "names": ["d", "b", "GeolocationError", "Geolocation", "__extends", "d", "b", "Graticule", "EventType_default", "Vector_default", "wrapX", "__extends", "d", "b", "ImageCanvas", "__extends", "d", "b", "VectorRenderTile", "__extends", "d", "b", "VectorTile"]
}
