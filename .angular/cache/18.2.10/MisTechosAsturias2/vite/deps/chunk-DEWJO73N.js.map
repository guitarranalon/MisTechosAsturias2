{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/geom/flat/transform.js", "../../../../../../node_modules/ol/geom/Geometry.js", "../../../../../../node_modules/ol/geom/GeometryLayout.js", "../../../../../../node_modules/ol/geom/SimpleGeometry.js"],
  "sourcesContent": ["/**\n * @module ol/geom/flat/transform\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var x = flatCoordinates[j];\n    var y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport Units from '../proj/Units.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { createEmpty, createOrUpdateEmpty, getHeight, returnOrUpdate } from '../extent.js';\nimport { get as getProjection, getTransform } from '../proj.js';\nimport { memoizeOne } from '../functions.js';\nimport { transform2D } from './flat/transform.js';\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = /** @class */function (_super) {\n  __extends(Geometry, _super);\n  function Geometry() {\n    var _this = _super.call(this) || this;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    _this.extent_ = createEmpty();\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.extentRevision_ = -1;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.simplifiedGeometryRevision = 0;\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} revision The geometry revision.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {\n      if (!opt_transform) {\n        return this.getSimplifiedGeometry(squaredTolerance);\n      }\n      var clone = this.clone();\n      clone.applyTransform(opt_transform);\n      return clone.getSimplifiedGeometry(squaredTolerance);\n    });\n    return _this;\n  }\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n   * @return {Geometry} Simplified geometry.\n   */\n  Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {\n    return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  Geometry.prototype.clone = function () {\n    return abstract();\n  };\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  Geometry.prototype.containsXY = function (x, y) {\n    var coord = this.getClosestPoint([x, y]);\n    return coord[0] === x && coord[1] === y;\n  };\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_closestPoint Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  Geometry.prototype.intersectsCoordinate = function (coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  Geometry.prototype.computeExtent = function (extent) {\n    return abstract();\n  };\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  Geometry.prototype.getExtent = function (opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      var extent = this.computeExtent(this.extent_);\n      if (isNaN(extent[0]) || isNaN(extent[1])) {\n        createOrUpdateEmpty(extent);\n      }\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, opt_extent);\n  };\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  Geometry.prototype.rotate = function (angle, anchor) {\n    abstract();\n  };\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n    abstract();\n  };\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n   * algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  Geometry.prototype.simplify = function (tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n    return abstract();\n  };\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   */\n  Geometry.prototype.getType = function () {\n    return abstract();\n  };\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   */\n  Geometry.prototype.applyTransform = function (transformFn) {\n    abstract();\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  Geometry.prototype.intersectsExtent = function (extent) {\n    return abstract();\n  };\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  Geometry.prototype.translate = function (deltaX, deltaY) {\n    abstract();\n  };\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  Geometry.prototype.transform = function (source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    var sourceProj = getProjection(source);\n    var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {\n      var pixelExtent = sourceProj.getExtent();\n      var projectedExtent = sourceProj.getWorldExtent();\n      var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n      return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n    } : getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n  return Geometry;\n}(BaseObject);\nexport default Geometry;\n", "/**\n * @module ol/geom/GeometryLayout\n */\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nexport default {\n  XY: 'XY',\n  XYZ: 'XYZ',\n  XYM: 'XYM',\n  XYZM: 'XYZM'\n};\n", "var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport { rotate, scale, transform2D, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nvar SimpleGeometry = /** @class */function (_super) {\n  __extends(SimpleGeometry, _super);\n  function SimpleGeometry() {\n    var _this = _super.call(this) || this;\n    /**\n     * @protected\n     * @type {import(\"./GeometryLayout.js\").default}\n     */\n    _this.layout = GeometryLayout.XY;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.stride = 2;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    _this.flatCoordinates = null;\n    return _this;\n  }\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  SimpleGeometry.prototype.computeExtent = function (extent) {\n    return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n  };\n  /**\n   * @abstract\n   * @return {Array<*>} Coordinates.\n   */\n  SimpleGeometry.prototype.getCoordinates = function () {\n    return abstract();\n  };\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  SimpleGeometry.prototype.getFirstCoordinate = function () {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  SimpleGeometry.prototype.getFlatCoordinates = function () {\n    return this.flatCoordinates;\n  };\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  SimpleGeometry.prototype.getLastCoordinate = function () {\n    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n  };\n  /**\n   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\n   * @return {import(\"./GeometryLayout.js\").default} Layout.\n   * @api\n   */\n  SimpleGeometry.prototype.getLayout = function () {\n    return this.layout;\n  };\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    } else {\n      // Simplification did not actually remove any coordinates.  We now know\n      // that any calls to getSimplifiedGeometry with a squaredTolerance less\n      // than or equal to the current squaredTolerance will also not have any\n      // effect.  This allows us to short circuit simplification (saving CPU\n      // cycles) and prevents the cache of simplified geometries from filling\n      // up with useless identical copies of this geometry (saving memory).\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n    return this;\n  };\n  /**\n   * @return {number} Stride.\n   */\n  SimpleGeometry.prototype.getStride = function () {\n    return this.stride;\n  };\n  /**\n   * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  };\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   */\n  SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {\n    abstract();\n  };\n  /**\n   * @param {import(\"./GeometryLayout.js\").default|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {\n    /** @type {number} */\n    var stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (var i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = GeometryLayout.XY;\n          this.stride = 2;\n          return;\n        } else {\n          coordinates = /** @type {Array} */coordinates[0];\n        }\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  };\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  SimpleGeometry.prototype.applyTransform = function (transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  };\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  SimpleGeometry.prototype.rotate = function (angle, anchor) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n    var sy = opt_sy;\n    if (sy === undefined) {\n      sy = sx;\n    }\n    var anchor = opt_anchor;\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  SimpleGeometry.prototype.translate = function (deltaX, deltaY) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n      this.changed();\n    }\n  };\n  return SimpleGeometry;\n}(Geometry);\n/**\n * @param {number} stride Stride.\n * @return {import(\"./GeometryLayout.js\").default} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  var layout;\n  if (stride == 2) {\n    layout = GeometryLayout.XY;\n  } else if (stride == 3) {\n    layout = GeometryLayout.XYZ;\n  } else if (stride == 4) {\n    layout = GeometryLayout.XYZM;\n  }\n  return /** @type {import(\"./GeometryLayout.js\").default} */layout;\n}\n/**\n * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  var stride;\n  if (layout == GeometryLayout.XY) {\n    stride = 2;\n  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n    stride = 3;\n  } else if (layout == GeometryLayout.XYZM) {\n    stride = 4;\n  }\n  return /** @type {number} */stride;\n}\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, opt_dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  } else {\n    var stride = simpleGeometry.getStride();\n    return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);\n  }\n}\nexport default SimpleGeometry;\n"],
  "mappings": "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",
  "names": ["d", "b", "Geometry", "scale", "__extends", "d", "b", "SimpleGeometry"]
}
