{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/ViewHint.js", "../../../../../../node_modules/ol/geom/flat/simplify.js", "../../../../../../node_modules/ol/geom/flat/inflate.js"],
  "sourcesContent": ["/**\n * @module ol/ViewHint\n */\n/**\n * @enum {number}\n */\nexport default {\n  ANIMATING: 0,\n  INTERACTING: 1\n};\n", "/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredDistance, squaredSegmentDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  var stack = [offset, end - stride];\n  var index = 0;\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n    for (var i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance_1 > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance_1;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (var i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  var x1 = snap(flatCoordinates[offset], tolerance);\n  var y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  var x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    var x3 = snap(flatCoordinates[offset], tolerance);\n    var y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n", "/**\n * @module ol/geom/flat/inflate\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>=} opt_coordinates Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\n  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>=} opt_coordinatess Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n  var i = 0;\n  for (var j = 0, jj = ends.length; j < jj; ++j) {\n    var end = ends[j];\n    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>=} opt_coordinatesss\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n  var i = 0;\n  for (var j = 0, jj = endss.length; j < jj; ++j) {\n    var ends = endss[j];\n    coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n"],
  "mappings": "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",
  "names": []
}
