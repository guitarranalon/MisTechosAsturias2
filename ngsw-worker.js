!function(){"use strict";class NotFound{constructor(table,key){this.table=table,this.key=key}}class CacheTable{constructor(table,cache,adapter,cacheQueryOptions){this.table=table,this.cache=cache,this.adapter=adapter,this.cacheQueryOptions=cacheQueryOptions}request(key){return this.adapter.newRequest("/"+key)}delete(key){return this.cache.delete(this.request(key),this.cacheQueryOptions)}keys(){return this.cache.keys().then((requests=>requests.map((req=>req.url.substr(1)))))}read(key){return this.cache.match(this.request(key),this.cacheQueryOptions).then((res=>void 0===res?Promise.reject(new NotFound(this.table,key)):res.json()))}write(key,value){return this.cache.put(this.request(key),this.adapter.newResponse(JSON.stringify(value)))}}function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))}var UpdateCacheStatus=function(UpdateCacheStatus){return UpdateCacheStatus[UpdateCacheStatus.NOT_CACHED=0]="NOT_CACHED",UpdateCacheStatus[UpdateCacheStatus.CACHED_BUT_UNUSED=1]="CACHED_BUT_UNUSED",UpdateCacheStatus[UpdateCacheStatus.CACHED=2]="CACHED",UpdateCacheStatus}({});class SwCriticalError extends Error{constructor(){super(...arguments),this.isCritical=!0}}function errorToString(error){return error instanceof Error?`${error.message}\n${error.stack}`:`${error}`}class SwUnrecoverableStateError extends SwCriticalError{constructor(){super(...arguments),this.isUnrecoverableState=!0}}function sha1(str){const utf8=str;return _sha1(function(str,endian){const size=str.length+3>>>2,words32=[];for(let i=0;i<size;i++)words32[i]=wordAt(str,4*i,endian);return words32}(utf8,Endian.Big),8*utf8.length)}function sha1Binary(buffer){return _sha1(function(buffer,endian){const size=buffer.byteLength+3>>>2,words32=[],view=new Uint8Array(buffer);for(let i=0;i<size;i++)words32[i]=wordAt(view,4*i,endian);return words32}(buffer,Endian.Big),8*buffer.byteLength)}function _sha1(words32,len){const w=[];let[a,b,c,d,e]=[1732584193,4023233417,2562383102,271733878,3285377520];words32[len>>5]|=128<<24-len%32,words32[15+(len+64>>9<<4)]=len;for(let i=0;i<words32.length;i+=16){const[h0,h1,h2,h3,h4]=[a,b,c,d,e];for(let j=0;j<80;j++){w[j]=j<16?words32[i+j]:rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);const[f,k]=fk(j,b,c,d),temp=[rol32(a,5),f,e,k,w[j]].reduce(add32);[e,d,c,b,a]=[d,c,rol32(b,30),a,temp]}[a,b,c,d,e]=[add32(a,h0),add32(b,h1),add32(c,h2),add32(d,h3),add32(e,h4)]}return function(str){let hex="";for(let i=0;i<str.length;i++){const b=byteAt(str,i);hex+=(b>>>4).toString(16)+(15&b).toString(16)}return hex.toLowerCase()}(function(words32){return words32.reduce(((str,word)=>str+function(word){let str="";for(let i=0;i<4;i++)str+=String.fromCharCode(word>>>8*(3-i)&255);return str}(word)),"")}([a,b,c,d,e]))}function add32(a,b){return function(a,b){const low=(65535&a)+(65535&b),high=(a>>>16)+(b>>>16)+(low>>>16);return[high>>>16,high<<16|65535&low]}(a,b)[1]}function rol32(a,count){return a<<count|a>>>32-count}var Endian=function(Endian){return Endian[Endian.Little=0]="Little",Endian[Endian.Big=1]="Big",Endian}({});function fk(index,b,c,d){return index<20?[b&c|~b&d,1518500249]:index<40?[b^c^d,1859775393]:index<60?[b&c|b&d|c&d,2400959708]:[b^c^d,3395469782]}function byteAt(str,index){return"string"==typeof str?index>=str.length?0:255&str.charCodeAt(index):index>=str.byteLength?0:255&str[index]}function wordAt(str,index,endian){let word=0;if(endian===Endian.Big)for(let i=0;i<4;i++)word+=byteAt(str,index+i)<<24-8*i;else for(let i=0;i<4;i++)word+=byteAt(str,index+i)<<8*i;return word}class AssetGroup{constructor(scope,adapter,idle,config,hashes,db,prefix){this.scope=scope,this.adapter=adapter,this.idle=idle,this.config=config,this.hashes=hashes,this.db=db,this.prefix=prefix,this.inFlightRequests=new Map,this.urls=[],this.patterns=[],this.name=config.name,this.urls=config.urls.map((url=>adapter.normalizeUrl(url))),this.patterns=config.patterns.map((pattern=>new RegExp(pattern))),this.cache=scope.caches.open(`${this.prefix}:${config.name}:cache`),this.metadata=this.db.open(`${this.prefix}:${config.name}:meta`,config.cacheQueryOptions)}cacheStatus(url){return __awaiter(this,void 0,void 0,(function*(){const cache=yield this.cache,meta=yield this.metadata,req=this.adapter.newRequest(url);if(void 0===(yield cache.match(req,this.config.cacheQueryOptions)))return UpdateCacheStatus.NOT_CACHED;try{if(!(yield meta.read(req.url)).used)return UpdateCacheStatus.CACHED_BUT_UNUSED}catch(_){}return UpdateCacheStatus.CACHED}))}cleanup(){return __awaiter(this,void 0,void 0,(function*(){yield this.scope.caches.delete(`${this.prefix}:${this.config.name}:cache`),yield this.db.delete(`${this.prefix}:${this.config.name}:meta`)}))}handleFetch(req,ctx){return __awaiter(this,void 0,void 0,(function*(){const url=this.adapter.normalizeUrl(req.url);if(-1!==this.urls.indexOf(url)||this.patterns.some((pattern=>pattern.test(url)))){const cache=yield this.cache,cachedResponse=yield cache.match(req,this.config.cacheQueryOptions);if(void 0!==cachedResponse)return this.hashes.has(url)||(yield this.needToRevalidate(req,cachedResponse))&&this.idle.schedule(`revalidate(${this.prefix}, ${this.config.name}): ${req.url}`,(()=>__awaiter(this,void 0,void 0,(function*(){yield this.fetchAndCacheOnce(req)})))),cachedResponse;return(yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url))).clone()}return null}))}needToRevalidate(req,res){return __awaiter(this,void 0,void 0,(function*(){if(res.headers.has("Cache-Control")){const cacheDirectives=res.headers.get("Cache-Control").split(",").map((v=>v.trim())).map((v=>v.split("=")));cacheDirectives.forEach((v=>v[0]=v[0].toLowerCase()));const maxAgeDirective=cacheDirectives.find((v=>"max-age"===v[0])),cacheAge=maxAgeDirective?maxAgeDirective[1]:void 0;if(!cacheAge)return!0;try{const maxAge=1e3*parseInt(cacheAge);let ts;try{const metaTable=yield this.metadata;ts=(yield metaTable.read(req.url)).ts}catch(_a){const date=res.headers.get("Date");if(null===date)return!0;ts=Date.parse(date)}const age=this.adapter.time-ts;return age<0||age>maxAge}catch(_b){return!0}}else{if(!res.headers.has("Expires"))return!0;{const expiresStr=res.headers.get("Expires");try{return this.adapter.time>Date.parse(expiresStr)}catch(_c){return!0}}}}))}fetchFromCacheOnly(url){return __awaiter(this,void 0,void 0,(function*(){const cache=yield this.cache,metaTable=yield this.metadata,request=this.adapter.newRequest(url),response=yield cache.match(request,this.config.cacheQueryOptions);if(void 0===response)return null;let metadata;try{metadata=yield metaTable.read(request.url)}catch(_a){}return{response:response,metadata:metadata}}))}unhashedResources(){return __awaiter(this,void 0,void 0,(function*(){const cache=yield this.cache;return(yield cache.keys()).map((request=>this.adapter.normalizeUrl(request.url))).filter((url=>!this.hashes.has(url)))}))}fetchAndCacheOnce(req,used=!0){return __awaiter(this,void 0,void 0,(function*(){if(this.inFlightRequests.has(req.url))return this.inFlightRequests.get(req.url);const fetchOp=this.fetchFromNetwork(req);this.inFlightRequests.set(req.url,fetchOp);try{const res=yield fetchOp;if(!res.ok)throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);try{const cache=yield this.scope.caches.open(`${this.prefix}:${this.config.name}:cache`);if(yield cache.put(req,res.clone()),!this.hashes.has(this.adapter.normalizeUrl(req.url))){const meta={ts:this.adapter.time,used:used},metaTable=yield this.metadata;yield metaTable.write(req.url,meta)}return res}catch(err){throw new SwCriticalError(`Failed to update the caches for request to '${req.url}' (fetchAndCacheOnce): ${errorToString(err)}`)}}finally{this.inFlightRequests.delete(req.url)}}))}fetchFromNetwork(req,redirectLimit=3){return __awaiter(this,void 0,void 0,(function*(){const res=yield this.cacheBustedFetchFromNetwork(req);if(res.redirected&&res.url){if(0===redirectLimit)throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);return this.fetchFromNetwork(this.adapter.newRequest(res.url),redirectLimit-1)}return res}))}cacheBustedFetchFromNetwork(req){return __awaiter(this,void 0,void 0,(function*(){const url=this.adapter.normalizeUrl(req.url);if(this.hashes.has(url)){const canonicalHash=this.hashes.get(url);let response=yield this.safeFetch(req),makeCacheBustedRequest=response.ok;if(makeCacheBustedRequest){makeCacheBustedRequest=sha1Binary(yield response.clone().arrayBuffer())!==canonicalHash}if(makeCacheBustedRequest){const cacheBustReq=this.adapter.newRequest(this.cacheBust(req.url));if(response=yield this.safeFetch(cacheBustReq),response.ok){const cacheBustedHash=sha1Binary(yield response.clone().arrayBuffer());if(canonicalHash!==cacheBustedHash)throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`)}}if(!response.ok&&404===response.status)throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);return response}return this.safeFetch(req)}))}maybeUpdate(updateFrom,req,cache){return __awaiter(this,void 0,void 0,(function*(){const url=this.adapter.normalizeUrl(req.url),meta=yield this.metadata;if(this.hashes.has(url)){const hash=this.hashes.get(url),res=yield updateFrom.lookupResourceWithHash(url,hash);if(null!==res)return yield cache.put(req,res),yield meta.write(req.url,{ts:this.adapter.time,used:!1}),!0}return!1}))}cacheBust(url){return url+(-1===url.indexOf("?")?"?":"&")+"ngsw-cache-bust="+Math.random()}safeFetch(req){return __awaiter(this,void 0,void 0,(function*(){try{return yield this.scope.fetch(req)}catch(_a){return this.adapter.newResponse("",{status:504,statusText:"Gateway Timeout"})}}))}}class PrefetchAssetGroup extends AssetGroup{initializeFully(updateFrom){return __awaiter(this,void 0,void 0,(function*(){const cache=yield this.cache;if(yield this.urls.reduce(((previous,url)=>__awaiter(this,void 0,void 0,(function*(){yield previous;const req=this.adapter.newRequest(url);void 0!==(yield cache.match(req,this.config.cacheQueryOptions))||void 0!==updateFrom&&(yield this.maybeUpdate(updateFrom,req,cache))||(yield this.fetchAndCacheOnce(req,!1))}))),Promise.resolve()),void 0!==updateFrom){const metaTable=yield this.metadata;yield(yield updateFrom.previouslyCachedResources()).filter((url=>-1!==this.urls.indexOf(url)||this.patterns.some((pattern=>pattern.test(url))))).reduce(((previous,url)=>__awaiter(this,void 0,void 0,(function*(){yield previous;const req=this.adapter.newRequest(url);if(void 0!==(yield cache.match(req,this.config.cacheQueryOptions)))return;const res=yield updateFrom.lookupResourceWithoutHash(url);null!==res&&void 0!==res.metadata&&(yield cache.put(req,res.response),yield metaTable.write(req.url,Object.assign(Object.assign({},res.metadata),{used:!1})))}))),Promise.resolve())}}))}}class LazyAssetGroup extends AssetGroup{initializeFully(updateFrom){return __awaiter(this,void 0,void 0,(function*(){if(void 0===updateFrom)return;const cache=yield this.cache;yield this.urls.reduce(((previous,url)=>__awaiter(this,void 0,void 0,(function*(){yield previous;const req=this.adapter.newRequest(url);if(void 0!==(yield cache.match(req,this.config.cacheQueryOptions)))return;const updated=yield this.maybeUpdate(updateFrom,req,cache);if("prefetch"===this.config.updateMode&&!updated){if((yield updateFrom.recentCacheStatus(url))!==UpdateCacheStatus.CACHED)return;yield this.fetchAndCacheOnce(req,!1)}}))),Promise.resolve())}))}}class LruList{constructor(state){void 0===state&&(state={head:null,tail:null,map:{},count:0}),this.state=state}get size(){return this.state.count}pop(){if(null===this.state.tail)return null;const url=this.state.tail;return this.remove(url),url}remove(url){const node=this.state.map[url];if(void 0===node)return!1;if(this.state.head===url){if(null===node.next)return this.state.head=null,this.state.tail=null,this.state.map={},this.state.count=0,!0;const next=this.state.map[node.next];return next.previous=null,this.state.head=next.url,node.next=null,delete this.state.map[url],this.state.count--,!0}return this.state.map[node.previous].next=node.next,null!==node.next?this.state.map[node.next].previous=node.previous:this.state.tail=node.previous,node.next=null,node.previous=null,delete this.state.map[url],this.state.count--,!0}accessed(url){if(this.state.head===url)return;const node=this.state.map[url]||{url:url,next:null,previous:null};void 0!==this.state.map[url]&&this.remove(url),null!==this.state.head&&(this.state.map[this.state.head].previous=url),node.next=this.state.head,this.state.head=url,null===this.state.tail&&(this.state.tail=url),this.state.map[url]=node,this.state.count++}}class DataGroup{constructor(scope,adapter,config,db,debugHandler,prefix){this.scope=scope,this.adapter=adapter,this.config=config,this.db=db,this.debugHandler=debugHandler,this.prefix=prefix,this._lru=null,this.patterns=this.config.patterns.map((pattern=>new RegExp(pattern))),this.cache=this.scope.caches.open(`${this.prefix}:dynamic:${this.config.name}:cache`),this.lruTable=this.db.open(`${this.prefix}:dynamic:${this.config.name}:lru`,this.config.cacheQueryOptions),this.ageTable=this.db.open(`${this.prefix}:dynamic:${this.config.name}:age`,this.config.cacheQueryOptions)}lru(){return __awaiter(this,void 0,void 0,(function*(){if(null===this._lru){const table=yield this.lruTable;try{this._lru=new LruList(yield table.read("lru"))}catch(_a){this._lru=new LruList}}return this._lru}))}syncLru(){return __awaiter(this,void 0,void 0,(function*(){if(null===this._lru)return;const table=yield this.lruTable;try{return table.write("lru",this._lru.state)}catch(err){this.debugHandler.log(err,`DataGroup(${this.config.name}@${this.config.version}).syncLru()`)}}))}handleFetch(req,ctx){return __awaiter(this,void 0,void 0,(function*(){if(!this.patterns.some((pattern=>pattern.test(req.url))))return null;const lru=yield this.lru();switch(req.method){case"OPTIONS":return null;case"GET":case"HEAD":switch(this.config.strategy){case"freshness":return this.handleFetchWithFreshness(req,ctx,lru);case"performance":return this.handleFetchWithPerformance(req,ctx,lru);default:throw new Error(`Unknown strategy: ${this.config.strategy}`)}default:return lru.remove(req.url)&&(yield this.clearCacheForUrl(req.url)),yield this.syncLru(),this.safeFetch(req)}}))}handleFetchWithPerformance(req,ctx,lru){return __awaiter(this,void 0,void 0,(function*(){let res=null;const fromCache=yield this.loadFromCache(req,lru);if(null!==fromCache&&(res=fromCache.res,void 0!==this.config.refreshAheadMs&&fromCache.age>=this.config.refreshAheadMs&&ctx.waitUntil(this.safeCacheResponse(req,this.safeFetch(req),lru))),null!==res)return res;const[timeoutFetch,networkFetch]=this.networkFetchWithTimeout(req);return res=yield timeoutFetch,void 0===res?(res=this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"}),ctx.waitUntil(this.safeCacheResponse(req,networkFetch,lru))):yield this.safeCacheResponse(req,res,lru),res}))}handleFetchWithFreshness(req,ctx,lru){return __awaiter(this,void 0,void 0,(function*(){const[timeoutFetch,networkFetch]=this.networkFetchWithTimeout(req);let res;try{res=yield timeoutFetch}catch(_a){res=void 0}if(void 0===res){ctx.waitUntil(this.safeCacheResponse(req,networkFetch,lru,!0));const fromCache=yield this.loadFromCache(req,lru);res=null!==fromCache?fromCache.res:null}else yield this.safeCacheResponse(req,res,lru,!0);return null!==res?res:networkFetch}))}networkFetchWithTimeout(req){if(void 0!==this.config.timeoutMs){const networkFetch=this.scope.fetch(req),safeNetworkFetch=(()=>__awaiter(this,void 0,void 0,(function*(){try{return yield networkFetch}catch(_a){return this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}})))(),networkFetchUndefinedError=(()=>__awaiter(this,void 0,void 0,(function*(){try{return yield networkFetch}catch(_b){return}})))(),timeout=this.adapter.timeout(this.config.timeoutMs);return[Promise.race([networkFetchUndefinedError,timeout]),safeNetworkFetch]}{const networkFetch=this.safeFetch(req);return[networkFetch,networkFetch]}}safeCacheResponse(req,resOrPromise,lru,okToCacheOpaque){return __awaiter(this,void 0,void 0,(function*(){try{const res=yield resOrPromise;try{yield this.cacheResponse(req,res,lru,okToCacheOpaque)}catch(err){this.debugHandler.log(err,`DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`)}}catch(_a){}}))}loadFromCache(req,lru){return __awaiter(this,void 0,void 0,(function*(){const cache=yield this.cache;let res=yield cache.match(req,this.config.cacheQueryOptions);if(void 0!==res){try{const ageTable=yield this.ageTable,age=this.adapter.time-(yield ageTable.read(req.url)).age;if(age<=this.config.maxAge)return lru.accessed(req.url),{res:res,age:age}}catch(_a){}lru.remove(req.url),yield this.clearCacheForUrl(req.url),yield this.syncLru()}return null}))}cacheResponse(req,res,lru,okToCacheOpaque=!1){return __awaiter(this,void 0,void 0,(function*(){if(!(res.ok||okToCacheOpaque&&"opaque"===res.type))return;if(lru.size>=this.config.maxSize){const evictedUrl=lru.pop();null!==evictedUrl&&(yield this.clearCacheForUrl(evictedUrl))}lru.accessed(req.url),yield(yield this.cache).put(req,res.clone());const ageTable=yield this.ageTable;yield ageTable.write(req.url,{age:this.adapter.time}),yield this.syncLru()}))}cleanup(){return __awaiter(this,void 0,void 0,(function*(){yield Promise.all([this.scope.caches.delete(`${this.prefix}:dynamic:${this.config.name}:cache`),this.db.delete(`${this.prefix}:dynamic:${this.config.name}:age`),this.db.delete(`${this.prefix}:dynamic:${this.config.name}:lru`)])}))}clearCacheForUrl(url){return __awaiter(this,void 0,void 0,(function*(){const[cache,ageTable]=yield Promise.all([this.cache,this.ageTable]);yield Promise.all([cache.delete(this.adapter.newRequest(url,{method:"GET"}),this.config.cacheQueryOptions),cache.delete(this.adapter.newRequest(url,{method:"HEAD"}),this.config.cacheQueryOptions),ageTable.delete(url)])}))}safeFetch(req){return __awaiter(this,void 0,void 0,(function*(){try{return this.scope.fetch(req)}catch(_a){return this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}}))}}const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS=[{positive:!0,regex:"^/.*$"},{positive:!1,regex:"^/.*\\.[^/]*$"},{positive:!1,regex:"^/.*__"}];class AppVersion{constructor(scope,adapter,database,idle,debugHandler,manifest,manifestHash){this.scope=scope,this.adapter=adapter,this.database=database,this.idle=idle,this.debugHandler=debugHandler,this.manifest=manifest,this.manifestHash=manifestHash,this.hashTable=new Map,this.indexUrl=this.adapter.normalizeUrl(this.manifest.index),this._okay=!0,Object.keys(this.manifest.hashTable).forEach((url=>{this.hashTable.set(adapter.normalizeUrl(url),this.manifest.hashTable[url])})),this.assetGroups=(manifest.assetGroups||[]).map((config=>{const prefix=`${adapter.cacheNamePrefix}:${this.manifestHash}:assets`;switch(config.installMode){case"prefetch":return new PrefetchAssetGroup(this.scope,this.adapter,this.idle,config,this.hashTable,this.database,prefix);case"lazy":return new LazyAssetGroup(this.scope,this.adapter,this.idle,config,this.hashTable,this.database,prefix)}})),this.dataGroups=(manifest.dataGroups||[]).map((config=>new DataGroup(this.scope,this.adapter,config,this.database,this.debugHandler,`${adapter.cacheNamePrefix}:${config.version}:data`))),manifest.navigationUrls=manifest.navigationUrls||BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;const includeUrls=manifest.navigationUrls.filter((spec=>spec.positive)),excludeUrls=manifest.navigationUrls.filter((spec=>!spec.positive));this.navigationUrls={include:includeUrls.map((spec=>new RegExp(spec.regex))),exclude:excludeUrls.map((spec=>new RegExp(spec.regex)))}}get okay(){return this._okay}initializeFully(updateFrom){return __awaiter(this,void 0,void 0,(function*(){try{yield this.assetGroups.reduce(((previous,group)=>__awaiter(this,void 0,void 0,(function*(){return yield previous,group.initializeFully(updateFrom)}))),Promise.resolve())}catch(err){throw this._okay=!1,err}}))}handleFetch(req,context){return __awaiter(this,void 0,void 0,(function*(){const asset=yield this.assetGroups.reduce(((potentialResponse,group)=>__awaiter(this,void 0,void 0,(function*(){const resp=yield potentialResponse;return null!==resp?resp:group.handleFetch(req,context)}))),Promise.resolve(null));if(null!==asset)return asset;const data=yield this.dataGroups.reduce(((potentialResponse,group)=>__awaiter(this,void 0,void 0,(function*(){const resp=yield potentialResponse;return null!==resp?resp:group.handleFetch(req,context)}))),Promise.resolve(null));if(null!==data)return data;if(this.adapter.normalizeUrl(req.url)!==this.indexUrl&&this.isNavigationRequest(req)){if("freshness"===this.manifest.navigationRequestStrategy)try{return yield this.scope.fetch(req)}catch(_a){}return this.handleFetch(this.adapter.newRequest(this.indexUrl),context)}return null}))}isNavigationRequest(req){if("navigate"!==req.mode)return!1;if(!this.acceptsTextHtml(req))return!1;const urlPrefix=this.scope.registration.scope.replace(/\/$/,""),urlWithoutQueryOrHash=(req.url.startsWith(urlPrefix)?req.url.substr(urlPrefix.length):req.url).replace(/[?#].*$/,"");return this.navigationUrls.include.some((regex=>regex.test(urlWithoutQueryOrHash)))&&!this.navigationUrls.exclude.some((regex=>regex.test(urlWithoutQueryOrHash)))}lookupResourceWithHash(url,hash){return __awaiter(this,void 0,void 0,(function*(){if(!this.hashTable.has(url))return null;if(this.hashTable.get(url)!==hash)return null;const cacheState=yield this.lookupResourceWithoutHash(url);return cacheState&&cacheState.response}))}lookupResourceWithoutHash(url){return this.assetGroups.reduce(((potentialResponse,group)=>__awaiter(this,void 0,void 0,(function*(){const resp=yield potentialResponse;return null!==resp?resp:group.fetchFromCacheOnly(url)}))),Promise.resolve(null))}previouslyCachedResources(){return this.assetGroups.reduce(((resources,group)=>__awaiter(this,void 0,void 0,(function*(){return(yield resources).concat(yield group.unhashedResources())}))),Promise.resolve([]))}recentCacheStatus(url){return __awaiter(this,void 0,void 0,(function*(){return this.assetGroups.reduce(((current,group)=>__awaiter(this,void 0,void 0,(function*(){const status=yield current;if(status===UpdateCacheStatus.CACHED)return status;const groupStatus=yield group.cacheStatus(url);return groupStatus===UpdateCacheStatus.NOT_CACHED?status:groupStatus}))),Promise.resolve(UpdateCacheStatus.NOT_CACHED))}))}cleanup(){return __awaiter(this,void 0,void 0,(function*(){yield Promise.all(this.assetGroups.map((group=>group.cleanup()))),yield Promise.all(this.dataGroups.map((group=>group.cleanup())))}))}get appData(){return this.manifest.appData||null}acceptsTextHtml(req){const accept=req.headers.get("Accept");if(null===accept)return!1;return accept.split(",").some((value=>"text/html"===value.trim().toLowerCase()))}}class DebugHandler{constructor(driver,adapter){this.driver=driver,this.adapter=adapter,this.debugLogA=[],this.debugLogB=[]}handleFetch(req){return __awaiter(this,void 0,void 0,(function*(){const[state,versions,idle]=yield Promise.all([this.driver.debugState(),this.driver.debugVersions(),this.driver.debugIdleState()]),msgState=`NGSW Debug Info:\n\nDriver state: ${state.state} (${state.why})\nLatest manifest hash: ${state.latestHash||"none"}\nLast update check: ${this.since(state.lastUpdateCheck)}`,msgVersions=versions.map((version=>`=== Version ${version.hash} ===\n\nClients: ${version.clients.join(", ")}`)).join("\n\n"),msgIdle=`=== Idle Task Queue ===\nLast update tick: ${this.since(idle.lastTrigger)}\nLast update run: ${this.since(idle.lastRun)}\nTask queue:\n${idle.queue.map((v=>" * "+v)).join("\n")}\n\nDebug log:\n${this.formatDebugLog(this.debugLogB)}\n${this.formatDebugLog(this.debugLogA)}\n`;return this.adapter.newResponse(`${msgState}\n\n${msgVersions}\n\n${msgIdle}`,{headers:this.adapter.newHeaders({"Content-Type":"text/plain"})})}))}since(time){if(null===time)return"never";let age=this.adapter.time-time;const days=Math.floor(age/864e5);age%=864e5;const hours=Math.floor(age/36e5);age%=36e5;const minutes=Math.floor(age/6e4);age%=6e4;const seconds=Math.floor(age/1e3),millis=age%1e3;return(days>0?`${days}d`:"")+(hours>0?`${hours}h`:"")+(minutes>0?`${minutes}m`:"")+(seconds>0?`${seconds}s`:"")+(millis>0?`${millis}u`:"")}log(value,context=""){100===this.debugLogA.length&&(this.debugLogB=this.debugLogA,this.debugLogA=[]),"string"!=typeof value&&(value=this.errorToString(value)),this.debugLogA.push({value:value,time:this.adapter.time,context:context})}errorToString(err){return`${err.name}(${err.message}, ${err.stack})`}formatDebugLog(log){return log.map((entry=>`[${this.since(entry.time)}] ${entry.value} ${entry.context}`)).join("\n")}}class IdleScheduler{constructor(adapter,threshold,debug){this.adapter=adapter,this.threshold=threshold,this.debug=debug,this.queue=[],this.scheduled=null,this.empty=Promise.resolve(),this.emptyResolve=null,this.lastTrigger=null,this.lastRun=null}trigger(){return __awaiter(this,void 0,void 0,(function*(){if(this.lastTrigger=this.adapter.time,0===this.queue.length)return;null!==this.scheduled&&(this.scheduled.cancel=!0);const scheduled={cancel:!1};this.scheduled=scheduled,yield this.adapter.timeout(this.threshold),scheduled.cancel||(this.scheduled=null,yield this.execute())}))}execute(){return __awaiter(this,void 0,void 0,(function*(){for(this.lastRun=this.adapter.time;this.queue.length>0;){const queue=this.queue;this.queue=[],yield queue.reduce(((previous,task)=>__awaiter(this,void 0,void 0,(function*(){yield previous;try{yield task.run()}catch(err){this.debug.log(err,`while running idle task ${task.desc}`)}}))),Promise.resolve())}null!==this.emptyResolve&&(this.emptyResolve(),this.emptyResolve=null),this.empty=Promise.resolve()}))}schedule(desc,run){this.queue.push({desc:desc,run:run}),null===this.emptyResolve&&(this.empty=new Promise((resolve=>{this.emptyResolve=resolve})))}get size(){return this.queue.length}get taskDescriptions(){return this.queue.map((task=>task.desc))}}function hashManifest(manifest){return sha1(JSON.stringify(manifest))}const NOTIFICATION_OPTION_NAMES=["actions","badge","body","data","dir","icon","image","lang","renotify","requireInteraction","silent","tag","timestamp","title","vibrate"];var DriverReadyState=function(DriverReadyState){return DriverReadyState[DriverReadyState.NORMAL=0]="NORMAL",DriverReadyState[DriverReadyState.EXISTING_CLIENTS_ONLY=1]="EXISTING_CLIENTS_ONLY",DriverReadyState[DriverReadyState.SAFE_MODE=2]="SAFE_MODE",DriverReadyState}({});const scope=self,adapter=new class{constructor(scopeUrl){this.scopeUrl=scopeUrl;const parsedScopeUrl=this.parseUrl(this.scopeUrl);this.origin=parsedScopeUrl.origin,this.cacheNamePrefix="ngsw:"+parsedScopeUrl.path}newRequest(input,init){return new Request(input,init)}newResponse(body,init){return new Response(body,init)}newHeaders(headers){return new Headers(headers)}isClient(source){return source instanceof Client}get time(){return Date.now()}normalizeUrl(url){const parsed=this.parseUrl(url,this.scopeUrl);return parsed.origin===this.origin?parsed.path:url}parseUrl(url,relativeTo){const parsed=relativeTo?new URL(url,relativeTo):new URL(url);return{origin:parsed.origin,path:parsed.pathname,search:parsed.search}}timeout(ms){return new Promise((resolve=>{setTimeout((()=>resolve()),ms)}))}}(scope.registration.scope);new class{constructor(scope,adapter,db){this.scope=scope,this.adapter=adapter,this.db=db,this.state=DriverReadyState.NORMAL,this.stateMessage="(nominal)",this.initialized=null,this.clientVersionMap=new Map,this.versions=new Map,this.latestHash=null,this.lastUpdateCheck=null,this.scheduledNavUpdateCheck=!1,this.loggedInvalidOnlyIfCachedRequest=!1,this.ngswStatePath=this.adapter.parseUrl("ngsw/state",this.scope.registration.scope).path,this.scope.addEventListener("install",(event=>{event.waitUntil(this.scope.skipWaiting())})),this.scope.addEventListener("activate",(event=>{event.waitUntil((()=>__awaiter(this,void 0,void 0,(function*(){yield this.scope.clients.claim(),this.idle.schedule("activate: cleanup-old-sw-caches",(()=>__awaiter(this,void 0,void 0,(function*(){try{yield this.cleanupOldSwCaches()}catch(err){this.debugger.log(err,"cleanupOldSwCaches @ activate: cleanup-old-sw-caches")}}))))})))()),null!==this.scope.registration.active&&this.scope.registration.active.postMessage({action:"INITIALIZE"})})),this.scope.addEventListener("fetch",(event=>this.onFetch(event))),this.scope.addEventListener("message",(event=>this.onMessage(event))),this.scope.addEventListener("push",(event=>this.onPush(event))),this.scope.addEventListener("notificationclick",(event=>this.onClick(event))),this.debugger=new DebugHandler(this,this.adapter),this.idle=new IdleScheduler(this.adapter,5e3,this.debugger)}onFetch(event){const req=event.request,scopeUrl=this.scope.registration.scope,requestUrlObj=this.adapter.parseUrl(req.url,scopeUrl);req.headers.has("ngsw-bypass")||/[?&]ngsw-bypass(?:[=&]|$)/i.test(requestUrlObj.search)||(requestUrlObj.path!==this.ngswStatePath?this.state!==DriverReadyState.SAFE_MODE?requestUrlObj.origin.startsWith("http:")&&scopeUrl.startsWith("https:")?this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`):"only-if-cached"!==req.cache||"same-origin"===req.mode?event.respondWith(this.handleFetch(event)):this.loggedInvalidOnlyIfCachedRequest||(this.loggedInvalidOnlyIfCachedRequest=!0,this.debugger.log("Ignoring invalid request: 'only-if-cached' can be set only with 'same-origin' mode",`Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`)):event.waitUntil(this.idle.trigger()):event.respondWith(this.debugger.handleFetch(req)))}onMessage(event){if(this.state===DriverReadyState.SAFE_MODE)return;const data=event.data;data&&data.action&&event.waitUntil((()=>__awaiter(this,void 0,void 0,(function*(){if("INITIALIZE"===data.action)return this.ensureInitialized(event);this.adapter.isClient(event.source)&&(yield this.ensureInitialized(event),yield this.handleMessage(data,event.source))})))())}onPush(msg){msg.data&&msg.waitUntil(this.handlePush(msg.data.json()))}onClick(event){event.waitUntil(this.handleClick(event.notification,event.action))}ensureInitialized(event){return __awaiter(this,void 0,void 0,(function*(){if(null!==this.initialized)return this.initialized;try{this.initialized=this.initialize(),yield this.initialized}catch(error){throw this.state=DriverReadyState.SAFE_MODE,this.stateMessage=`Initialization failed due to error: ${errorToString(error)}`,error}finally{event.waitUntil(this.idle.trigger())}}))}handleMessage(msg,from){return __awaiter(this,void 0,void 0,(function*(){if(function(msg){return"CHECK_FOR_UPDATES"===msg.action}(msg)){const action=(()=>__awaiter(this,void 0,void 0,(function*(){yield this.checkForUpdate()})))();yield this.reportStatus(from,action,msg.statusNonce)}else(function(msg){return"ACTIVATE_UPDATE"===msg.action})(msg)&&(yield this.reportStatus(from,this.updateClient(from),msg.statusNonce))}))}handlePush(data){return __awaiter(this,void 0,void 0,(function*(){if(yield this.broadcast({type:"PUSH",data:data}),!data.notification||!data.notification.title)return;const desc=data.notification;let options={};NOTIFICATION_OPTION_NAMES.filter((name=>desc.hasOwnProperty(name))).forEach((name=>options[name]=desc[name])),yield this.scope.registration.showNotification(desc.title,options)}))}handleClick(notification,action){return __awaiter(this,void 0,void 0,(function*(){notification.close();const options={};NOTIFICATION_OPTION_NAMES.filter((name=>name in notification)).forEach((name=>options[name]=notification[name])),yield this.broadcast({type:"NOTIFICATION_CLICK",data:{action:action,notification:options}})}))}reportStatus(client,promise,nonce){return __awaiter(this,void 0,void 0,(function*(){const response={type:"STATUS",nonce:nonce,status:!0};try{yield promise,client.postMessage(response)}catch(e){client.postMessage(Object.assign(Object.assign({},response),{status:!1,error:e.toString()}))}}))}updateClient(client){return __awaiter(this,void 0,void 0,(function*(){const existing=this.clientVersionMap.get(client.id);if(existing===this.latestHash)return;let previous;if(void 0!==existing){const existingVersion=this.versions.get(existing);previous=this.mergeHashWithAppData(existingVersion.manifest,existing)}this.clientVersionMap.set(client.id,this.latestHash),yield this.sync();const current=this.versions.get(this.latestHash),notice={type:"UPDATE_ACTIVATED",previous:previous,current:this.mergeHashWithAppData(current.manifest,this.latestHash)};client.postMessage(notice)}))}handleFetch(event){return __awaiter(this,void 0,void 0,(function*(){try{yield this.ensureInitialized(event)}catch(_a){return this.safeFetch(event.request)}"navigate"!==event.request.mode||this.scheduledNavUpdateCheck||(this.scheduledNavUpdateCheck=!0,this.idle.schedule("check-updates-on-navigation",(()=>__awaiter(this,void 0,void 0,(function*(){this.scheduledNavUpdateCheck=!1,yield this.checkForUpdate()})))));const appVersion=yield this.assignVersion(event);if(null===appVersion)return event.waitUntil(this.idle.trigger()),this.safeFetch(event.request);let res=null;try{res=yield appVersion.handleFetch(event.request,event)}catch(err){if(err.isUnrecoverableState&&(yield this.notifyClientsAboutUnrecoverableState(appVersion,err.message)),err.isCritical)return yield this.versionFailed(appVersion,err),event.waitUntil(this.idle.trigger()),this.safeFetch(event.request);throw err}return null===res?(event.waitUntil(this.idle.trigger()),this.safeFetch(event.request)):(event.waitUntil(this.idle.trigger()),res)}))}initialize(){return __awaiter(this,void 0,void 0,(function*(){const table=yield this.db.open("control");let manifests,assignments,latest;try{if([manifests,assignments,latest]=yield Promise.all([table.read("manifests"),table.read("assignments"),table.read("latest")]),!this.versions.has(latest.latest)&&!manifests.hasOwnProperty(latest.latest))throw this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`,"initialize: read from DB"),new Error(`Missing manifest for latest hash ${latest.latest}`);this.idle.schedule("init post-load (update, cleanup)",(()=>__awaiter(this,void 0,void 0,(function*(){yield this.checkForUpdate();try{yield this.cleanupCaches()}catch(err){this.debugger.log(err,"cleanupCaches @ init post-load")}}))))}catch(_){const manifest=yield this.fetchLatestManifest(),hash=hashManifest(manifest);manifests={},manifests[hash]=manifest,assignments={},latest={latest:hash},yield Promise.all([table.write("manifests",manifests),table.write("assignments",assignments),table.write("latest",latest)])}if(Object.keys(manifests).forEach((hash=>{const manifest=manifests[hash];this.versions.has(hash)||this.versions.set(hash,new AppVersion(this.scope,this.adapter,this.db,this.idle,this.debugger,manifest,hash))})),Object.keys(assignments).forEach((clientId=>{const hash=assignments[clientId];this.versions.has(hash)?this.clientVersionMap.set(clientId,hash):(this.clientVersionMap.set(clientId,latest.latest),this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`,"initialize: map assignments"))})),this.latestHash=latest.latest,!this.versions.has(latest.latest))throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);yield Promise.all(Object.keys(manifests).map((hash=>__awaiter(this,void 0,void 0,(function*(){try{yield this.scheduleInitialization(this.versions.get(hash))}catch(err){return this.debugger.log(err,`initialize: schedule init of ${hash}`),!1}})))))}))}lookupVersionByHash(hash,debugName="lookupVersionByHash"){if(!this.versions.has(hash))throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);return this.versions.get(hash)}assignVersion(event){return __awaiter(this,void 0,void 0,(function*(){const clientId=event.clientId;if(clientId){if(this.clientVersionMap.has(clientId)){const hash=this.clientVersionMap.get(clientId);let appVersion=this.lookupVersionByHash(hash,"assignVersion");if(this.state===DriverReadyState.NORMAL&&hash!==this.latestHash&&appVersion.isNavigationRequest(event.request)){if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");const client=yield this.scope.clients.get(clientId);yield this.updateClient(client),appVersion=this.lookupVersionByHash(this.latestHash,"assignVersion")}return appVersion}if(this.state!==DriverReadyState.NORMAL)return null;if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");return this.clientVersionMap.set(clientId,this.latestHash),yield this.sync(),this.lookupVersionByHash(this.latestHash,"assignVersion")}if(this.state!==DriverReadyState.NORMAL)return null;if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");return this.lookupVersionByHash(this.latestHash,"assignVersion")}))}fetchLatestManifest(ignoreOfflineError=!1){return __awaiter(this,void 0,void 0,(function*(){const res=yield this.safeFetch(this.adapter.newRequest("ngsw.json?ngsw-cache-bust="+Math.random()));if(!res.ok){if(404===res.status)yield this.deleteAllCaches(),yield this.scope.registration.unregister();else if((503===res.status||504===res.status)&&ignoreOfflineError)return null;throw new Error(`Manifest fetch failed! (status: ${res.status})`)}return this.lastUpdateCheck=this.adapter.time,res.json()}))}deleteAllCaches(){return __awaiter(this,void 0,void 0,(function*(){yield(yield this.scope.caches.keys()).filter((key=>key.startsWith(`${this.adapter.cacheNamePrefix}:`))).reduce(((previous,key)=>__awaiter(this,void 0,void 0,(function*(){yield Promise.all([previous,this.scope.caches.delete(key)])}))),Promise.resolve())}))}scheduleInitialization(appVersion){return __awaiter(this,void 0,void 0,(function*(){const initialize=()=>__awaiter(this,void 0,void 0,(function*(){try{yield appVersion.initializeFully()}catch(err){this.debugger.log(err,`initializeFully for ${appVersion.manifestHash}`),yield this.versionFailed(appVersion,err)}}));if(this.scope.registration.scope.indexOf("://localhost")>-1)return initialize();this.idle.schedule(`initialization(${appVersion.manifestHash})`,initialize)}))}versionFailed(appVersion,err){return __awaiter(this,void 0,void 0,(function*(){const broken=Array.from(this.versions.entries()).find((([hash,version])=>version===appVersion));if(void 0===broken)return;const brokenHash=broken[0],affectedClients=Array.from(this.clientVersionMap.entries()).filter((([clientId,hash])=>hash===brokenHash)).map((([clientId])=>clientId));this.latestHash===brokenHash?(this.state=DriverReadyState.EXISTING_CLIENTS_ONLY,this.stateMessage=`Degraded due to: ${errorToString(err)}`,affectedClients.forEach((clientId=>this.clientVersionMap.delete(clientId)))):affectedClients.forEach((clientId=>this.clientVersionMap.set(clientId,this.latestHash)));try{yield this.sync()}catch(err2){this.debugger.log(err2,`Driver.versionFailed(${err.message||err})`)}}))}setupUpdate(manifest,hash){return __awaiter(this,void 0,void 0,(function*(){const newVersion=new AppVersion(this.scope,this.adapter,this.db,this.idle,this.debugger,manifest,hash);if(1!==manifest.configVersion)throw yield this.deleteAllCaches(),yield this.scope.registration.unregister(),new Error(`Invalid config version: expected 1, got ${manifest.configVersion}.`);yield newVersion.initializeFully(this),this.versions.set(hash,newVersion),this.latestHash=hash,this.state===DriverReadyState.EXISTING_CLIENTS_ONLY&&(this.state=DriverReadyState.NORMAL,this.stateMessage="(nominal)"),yield this.sync(),yield this.notifyClientsAboutUpdate(newVersion)}))}checkForUpdate(){return __awaiter(this,void 0,void 0,(function*(){let hash="(unknown)";try{const manifest=yield this.fetchLatestManifest(!0);return null===manifest?(this.debugger.log("Check for update aborted. (Client or server offline.)"),!1):(hash=hashManifest(manifest),!this.versions.has(hash)&&(yield this.setupUpdate(manifest,hash),!0))}catch(err){return this.debugger.log(err,`Error occurred while updating to manifest ${hash}`),this.state=DriverReadyState.EXISTING_CLIENTS_ONLY,this.stateMessage=`Degraded due to failed initialization: ${errorToString(err)}`,!1}}))}sync(){return __awaiter(this,void 0,void 0,(function*(){const table=yield this.db.open("control"),manifests={};this.versions.forEach(((version,hash)=>{manifests[hash]=version.manifest}));const assignments={};this.clientVersionMap.forEach(((hash,clientId)=>{assignments[clientId]=hash}));const latest={latest:this.latestHash};yield Promise.all([table.write("manifests",manifests),table.write("assignments",assignments),table.write("latest",latest)])}))}cleanupCaches(){return __awaiter(this,void 0,void 0,(function*(){const activeClients=(yield this.scope.clients.matchAll()).map((client=>client.id));Array.from(this.clientVersionMap.keys()).filter((id=>-1===activeClients.indexOf(id))).forEach((id=>this.clientVersionMap.delete(id)));const usedVersions=new Set;this.clientVersionMap.forEach(((version,_)=>usedVersions.add(version)));const obsoleteVersions=Array.from(this.versions.keys()).filter((version=>!usedVersions.has(version)&&version!==this.latestHash));yield obsoleteVersions.reduce(((previous,version)=>__awaiter(this,void 0,void 0,(function*(){yield previous;try{const instance=this.versions.get(version);this.versions.delete(version),yield instance.cleanup()}catch(err){this.debugger.log(err,`cleanupCaches - cleanup ${version}`)}}))),Promise.resolve()),yield this.sync()}))}cleanupOldSwCaches(){return __awaiter(this,void 0,void 0,(function*(){const oldSwCacheNames=(yield this.scope.caches.keys()).filter((name=>/^ngsw:(?!\/)/.test(name)));yield Promise.all(oldSwCacheNames.map((name=>this.scope.caches.delete(name))))}))}lookupResourceWithHash(url,hash){return Array.from(this.versions.values()).reduce(((prev,version)=>__awaiter(this,void 0,void 0,(function*(){return null!==(yield prev)?prev:version.lookupResourceWithHash(url,hash)}))),Promise.resolve(null))}lookupResourceWithoutHash(url){return __awaiter(this,void 0,void 0,(function*(){yield this.initialized;const version=this.versions.get(this.latestHash);return version?version.lookupResourceWithoutHash(url):null}))}previouslyCachedResources(){return __awaiter(this,void 0,void 0,(function*(){yield this.initialized;const version=this.versions.get(this.latestHash);return version?version.previouslyCachedResources():[]}))}recentCacheStatus(url){return __awaiter(this,void 0,void 0,(function*(){const version=this.versions.get(this.latestHash);return version?version.recentCacheStatus(url):UpdateCacheStatus.NOT_CACHED}))}mergeHashWithAppData(manifest,hash){return{hash:hash,appData:manifest.appData}}notifyClientsAboutUnrecoverableState(appVersion,reason){return __awaiter(this,void 0,void 0,(function*(){const broken=Array.from(this.versions.entries()).find((([hash,version])=>version===appVersion));if(void 0===broken)return;const brokenHash=broken[0];Array.from(this.clientVersionMap.entries()).filter((([clientId,hash])=>hash===brokenHash)).map((([clientId])=>clientId)).forEach((clientId=>__awaiter(this,void 0,void 0,(function*(){(yield this.scope.clients.get(clientId)).postMessage({type:"UNRECOVERABLE_STATE",reason:reason})}))))}))}notifyClientsAboutUpdate(next){return __awaiter(this,void 0,void 0,(function*(){yield this.initialized;const clients=yield this.scope.clients.matchAll();yield clients.reduce(((previous,client)=>__awaiter(this,void 0,void 0,(function*(){yield previous;const version=this.clientVersionMap.get(client.id);if(void 0===version)return;if(version===this.latestHash)return;const current=this.versions.get(version),notice={type:"UPDATE_AVAILABLE",current:this.mergeHashWithAppData(current.manifest,version),available:this.mergeHashWithAppData(next.manifest,this.latestHash)};client.postMessage(notice)}))),Promise.resolve())}))}broadcast(msg){return __awaiter(this,void 0,void 0,(function*(){(yield this.scope.clients.matchAll()).forEach((client=>{client.postMessage(msg)}))}))}debugState(){return __awaiter(this,void 0,void 0,(function*(){return{state:DriverReadyState[this.state],why:this.stateMessage,latestHash:this.latestHash,lastUpdateCheck:this.lastUpdateCheck}}))}debugVersions(){return __awaiter(this,void 0,void 0,(function*(){return Array.from(this.versions.keys()).map((hash=>{const version=this.versions.get(hash),clients=Array.from(this.clientVersionMap.entries()).filter((([clientId,version])=>version===hash)).map((([clientId,version])=>clientId));return{hash:hash,manifest:version.manifest,clients:clients,status:""}}))}))}debugIdleState(){return __awaiter(this,void 0,void 0,(function*(){return{queue:this.idle.taskDescriptions,lastTrigger:this.idle.lastTrigger,lastRun:this.idle.lastRun}}))}safeFetch(req){return __awaiter(this,void 0,void 0,(function*(){try{return yield this.scope.fetch(req)}catch(err){return this.debugger.log(err,`Driver.fetch(${req.url})`),this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}}))}}(scope,adapter,new class{constructor(scope,adapter){this.scope=scope,this.adapter=adapter,this.tables=new Map}delete(name){return this.tables.has(name)&&this.tables.delete(name),this.scope.caches.delete(`${this.adapter.cacheNamePrefix}:db:${name}`)}list(){return this.scope.caches.keys().then((keys=>keys.filter((key=>key.startsWith(`${this.adapter.cacheNamePrefix}:db:`)))))}open(name,cacheQueryOptions){if(!this.tables.has(name)){const table=this.scope.caches.open(`${this.adapter.cacheNamePrefix}:db:${name}`).then((cache=>new CacheTable(name,cache,this.adapter,cacheQueryOptions)));this.tables.set(name,table)}return this.tables.get(name)}}(scope,adapter))}();